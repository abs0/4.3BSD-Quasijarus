h05372
s 00011/00006/00382
d D 7.5 88/06/29 17:55:22 bostic 46 45
c install approved copyright notice
e
s 00017/00003/00371
d D 7.4 88/05/14 11:10:37 karels 45 44
c impattach now takes name/unit instead of ubadevice; clean up output
c side when resetting
e
s 00009/00003/00365
d D 7.3 88/02/08 11:26:45 karels 44 43
c new copyright
e
s 00047/00054/00321
d D 7.2 88/02/08 10:26:08 karels 43 42
c new IMP interface
e
s 00001/00001/00374
d D 7.1 86/06/05 17:01:15 mckusick 42 41
c 4.3BSD release version
e
s 00001/00001/00374
d D 6.8 85/11/09 17:27:43 karels 41 40
c typo
e
s 00006/00006/00369
d D 6.7 85/11/08 19:15:58 karels 40 39
c make receive buffers large enough for trailing bits,
c avoiding segmenting max-size message and possibly losing end-of-message
e
s 00004/00003/00371
d D 6.6 85/09/16 22:36:23 karels 39 38
c pas ifp to if_rubaget
e
s 00001/00001/00373
d D 6.5 85/06/23 15:21:12 karels 38 37
c typo
e
s 00007/00001/00367
d D 6.4 85/06/08 13:51:17 mckusick 37 36
c Add copyright
e
s 00002/00000/00366
d D 6.3 85/05/01 09:06:43 karels 36 35
c move interface addresses into protocols; remove struct ether_addr again
e
s 00009/00009/00357
d D 6.2 84/08/29 20:42:07 bloom 35 34
c change ot includes.  no more ../h
e
s 00000/00000/00366
d D 6.1 83/07/29 07:37:01 sam 34 33
c 4.2 distribution
e
s 00000/00003/00366
d D 4.33 83/01/03 18:30:15 sam 33 32
c purge crud
e
s 00001/00001/00368
d D 4.32 82/12/17 12:12:57 sam 32 31
c sun merge
e
s 00001/00001/00368
d D 4.31 82/11/15 10:14:44 sam 31 30
c typo
e
s 00001/00001/00368
d D 4.30 82/11/13 23:04:16 sam 30 29
c merge 4.1b with 4.1c
e
s 00001/00001/00368
d D 4.29 82/10/24 14:37:47 wnj 29 28
c create netif directory
e
s 00002/00002/00367
d D 4.28 82/10/23 16:41:31 root 28 27
c lint
e
s 00001/00002/00368
d D 4.27 82/10/23 10:10:14 root 27 26
c impattach takes 2 arguments
e
s 00000/00000/00370
d D 4.26 82/10/22 01:13:54 root 26 25
c lint
e
s 00001/00001/00369
d D 4.25 82/10/22 00:00:05 root 25 24
c lint
e
s 00000/00000/00370
d D 4.24 82/10/21 21:03:38 root 24 23
c lint
e
s 00001/00000/00369
d D 4.23 82/10/20 01:44:57 root 23 22
c reset
e
s 00001/00001/00368
d D 4.22 82/10/17 20:29:21 root 22 21
c linterrs
e
s 00007/00005/00362
d D 4.21 82/10/10 16:58:11 root 21 20
c move vax headers into vax directories
e
s 00005/00005/00362
d D 4.20 82/10/09 06:08:58 wnj 20 19
c fix includes
e
s 00000/00007/00367
d D 4.19 82/06/20 00:51:43 sam 19 18
c purge COUNT stuff now that we can use gprof
e
s 00004/00043/00370
d D 4.18 82/06/15 15:15:54 sam 18 17
c clean up imp code after fixing problems
e
s 00008/00014/00405
d D 4.17 82/06/14 22:10:01 root 17 16
c more attempts by david
e
s 00085/00028/00334
d D 4.16 82/06/14 09:28:05 sam 16 15
c before carry to calder
e
s 00003/00001/00359
d D 4.15 82/04/20 14:02:05 sam 15 14
c make 3com kludge conditional
e
s 00001/00001/00359
d D 4.14 82/04/16 14:19:10 sam 14 13
c don't let driver sleep on interrupt stack if can't get bdp
e
s 00001/00000/00359
d D 4.13 82/04/11 02:38:59 feldman 13 12
c raise splimp for ec hack (temporary)
e
s 00009/00016/00350
d D 4.12 82/04/10 15:20:06 root 12 11
c unsatisfactory attempt to fix up imp
e
s 00006/00006/00360
d D 4.11 82/03/19 17:08:53 root 11 10
c IMPMTU fixup
e
s 00004/00004/00362
d D 4.10 82/03/19 00:16:39 root 10 9
c increase delays in init code
e
s 00002/00002/00364
d D 4.9 82/03/13 12:51:27 sam 9 8
c lint
e
s 00001/00001/00365
d D 4.8 82/03/12 16:07:52 sam 8 7
c misplaced (
e
s 00000/00004/00366
d D 4.7 82/02/27 12:59:47 root 7 6
c remove trash
e
s 00004/00003/00366
d D 4.6 82/02/25 13:16:21 wnj 6 5
c minor fixups with initialization
e
s 00003/00006/00366
d D 4.5 82/02/21 12:30:11 sam 5 4
c cleanup a bit
e
s 00002/00010/00370
d D 4.4 82/02/16 15:11:30 root 4 3
c first "working" imp driver
e
s 00105/00065/00275
d D 4.3 82/02/12 15:17:08 wnj 3 2
c closer to a working imp driver
e
s 00016/00013/00324
d D 4.2 82/02/01 22:49:52 sam 2 1
c cleanup before start of testing
e
s 00337/00000/00000
d D 4.1 82/02/01 13:52:32 sam 1 0
c date and time created 82/02/01 13:52:32 by sam
e
u
U
t
T
I 1
D 37
/*	%M%	%I%	%E%	*/
E 37
I 37
/*
D 42
 * Copyright (c) 1982 Regents of the University of California.
E 42
I 42
D 44
 * Copyright (c) 1982, 1986 Regents of the University of California.
E 42
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
E 44
I 44
D 46
 * Copyright (c) 1982,1986,1988 Regents of the University of California.
E 46
I 46
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
E 46
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
D 46
 * provided that this notice is preserved and that due credit is given
 * to the University of California at Berkeley. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
E 46
I 46
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
E 46
E 44
 *
 *	%W% (Berkeley) %G%
 */
E 37

#include "acc.h"
D 38
#ifdef NACC > 0
E 38
I 38
#if NACC > 0
E 38

/*
 * ACC LH/DH ARPAnet IMP interface driver.
 */
I 32
#include "../machine/pte.h"
E 32

D 35
#include "../h/param.h"
#include "../h/systm.h"
#include "../h/mbuf.h"
D 32
#include "../h/pte.h"
E 32
#include "../h/buf.h"
#include "../h/protosw.h"
#include "../h/socket.h"
D 21
#include "../h/ubareg.h"
#include "../h/ubavar.h"
D 3
#include "../h/accreg.h"
E 3
#include "../h/cpu.h"
#include "../h/mtpr.h"
E 21
#include "../h/vmmac.h"
E 35
I 35
#include "param.h"
#include "systm.h"
#include "mbuf.h"
#include "buf.h"
#include "protosw.h"
#include "socket.h"
#include "vmmac.h"
E 35
I 21

E 21
D 20
#include "../net/in.h"
#include "../net/in_systm.h"
E 20
#include "../net/if.h"
I 3
D 20
#include "../net/if_acc.h"
E 3
#include "../net/if_imp.h"
#include "../net/if_uba.h"
E 20
I 20
D 21
#include "../vaxif/if_acc.h"
E 21
#include "../netimp/if_imp.h"
I 21

#include "../vax/cpu.h"
#include "../vax/mtpr.h"
D 29
#include "../vaxif/if_acc.h"
E 29
I 29
D 35
#include "../vaxif/if_accreg.h"
E 29
E 21
#include "../vaxif/if_uba.h"
E 35
I 35
#include "if_accreg.h"
#include "if_uba.h"
E 35
I 21
#include "../vaxuba/ubareg.h"
#include "../vaxuba/ubavar.h"
E 21
E 20

int     accprobe(), accattach(), accrint(), accxint();
struct  uba_device *accinfo[NACC];
u_short accstd[] = { 0 };
struct  uba_driver accdriver =
	{ accprobe, 0, accattach, 0, accstd, "acc", accinfo };
D 43
#define	ACCUNIT(x)	minor(x)
E 43

D 43
int	accinit(), accstart(), accreset();
E 43
I 43
int	accinit(), accoutput(), accdown(), accreset();
E 43

/*
 * "Lower half" of IMP interface driver.
 *
 * Each IMP interface is handled by a common module which handles
 * the IMP-host protocol and a hardware driver which manages the
 * hardware specific details of talking with the IMP.
 *
 * The hardware portion of the IMP driver handles DMA and related
 * management of UNIBUS resources.  The IMP protocol module interprets
 * contents of these messages and "controls" the actions of the
 * hardware module during IMP resets, but not, for instance, during
 * UNIBUS resets.
 *
 * The two modules are coupled at "attach time", and ever after,
 * through the imp interface structure.  Higher level protocols,
 * e.g. IP, interact with the IMP driver, rather than the ACC.
 */
struct	acc_softc {
D 43
	struct	ifnet *acc_if;		/* pointer to IMP's ifnet struct */
	struct	impcb *acc_ic;		/* data structure shared with IMP */
E 43
I 43
	struct	imp_softc *acc_imp;	/* data structure shared with IMP */
E 43
	struct	ifuba acc_ifuba;	/* UNIBUS resources */
	struct	mbuf *acc_iq;		/* input reassembly queue */
	short	acc_olen;		/* size of last message sent */
	char	acc_flush;		/* flush remainder of message */
D 2
	char	acc_previous;		/* something on input queue */
E 2
} acc_softc[NACC];

I 16
D 18
#define	NACCDEBUG	10000
char	accdebug[NACCDEBUG];
int	accdebugx;

E 18
E 16
/*
 * Reset the IMP and cause a transmitter interrupt by
 * performing a null DMA.
 */
accprobe(reg)
	caddr_t reg;
{
	register int br, cvec;		/* r11, r10 value-result */
	register struct accdevice *addr = (struct accdevice *)reg;

D 19
COUNT(ACCPROBE);
E 19
#ifdef lint
	br = 0; cvec = br; br = cvec;
	accrint(0); accxint(0);
#endif
D 3
	addr->acc_icsr = ACC_RESET;
	DELAY(500000);
	addr->acc_ocsr = ACC_RESET;
	DELAY(500000);

	addr->acc_ocsr = OUT_BBACK;
	DELAY(500000);
	addr->acc_owc = 0;
	addr->acc_ocsr = ACC_IE | ACC_GO;
	DELAY(500000);
	addr->acc_ocsr = 0;
	/* interrupt was for transmit, push back to receive vector */
	if (cvec && cvec != 0x200)
E 3
I 3
	addr->icsr = ACC_RESET; DELAY(5000);
	addr->ocsr = ACC_RESET; DELAY(5000);
	addr->ocsr = OUT_BBACK; DELAY(5000);
	addr->owc = 0;
	addr->ocsr = ACC_IE | ACC_GO; DELAY(5000);
D 16
	addr->ocsr = 0;
E 16
I 16
D 17
	addr->icsr = ACC_RESET; DELAY(5000);
	addr->ocsr = ACC_RESET; DELAY(5000);
E 17
I 17
	addr->ocsr = 0;
E 17
E 16
	if (cvec && cvec != 0x200)	/* transmit -> receive */
E 3
		cvec -= 4;
I 13
D 15
	br = 0x16;		/* temporary ec hack */
E 15
I 15
D 33
#ifdef ECHACK
	br = 0x16;
#endif
E 33
E 15
E 13
	return (1);
}

/*
 * Call the IMP module to allow it to set up its internal
 * state, then tie the two modules together by setting up
 * the back pointers to common data structures.
 */
accattach(ui)
D 45
	struct uba_device *ui;
E 45
I 45
	register struct uba_device *ui;
E 45
{
	register struct acc_softc *sc = &acc_softc[ui->ui_unit];
	register struct impcb *ip;
D 43
	struct ifimpcb {
		struct	ifnet ifimp_if;
		struct	impcb ifimp_impcb;
	} *ifimp;
E 43

D 19
COUNT(ACCATTACH);
E 19
D 27
	if ((ifimp = (struct ifimpcb *)impattach(ui)) == 0)
E 27
I 27
D 28
	if ((ifimp = (struct ifimpcb *)impattach(ui, acreset)) == 0)
E 28
I 28
D 30
	if ((ifimp = (struct ifimpcb *)impattacch(ui, acreset)) == 0)
E 30
I 30
D 31
	if ((ifimp = (struct ifimpcb *)impattacch(ui, accreset)) == 0)
E 31
I 31
D 43
	if ((ifimp = (struct ifimpcb *)impattach(ui, accreset)) == 0)
E 43
I 43
D 45
	if ((sc->acc_imp = impattach(ui, accreset)) == 0)
E 45
I 45
	if ((sc->acc_imp = impattach(ui->ui_driver->ud_dname, ui->ui_unit,
	    accreset)) == 0)
E 45
E 43
E 31
E 30
E 28
E 27
D 3
		panic("accattach");		/* XXX */
E 3
I 3
D 39
		panic("accattach");
E 39
I 39
		return;
E 39
E 3
D 43
	sc->acc_if = &ifimp->ifimp_if;
	ip = &ifimp->ifimp_impcb;
	sc->acc_ic = ip;
E 43
I 43
	ip = &sc->acc_imp->imp_cb;
E 43
	ip->ic_init = accinit;
D 43
	ip->ic_start = accstart;
E 43
I 43
	ip->ic_output = accoutput;
	ip->ic_down = accdown;
E 43
I 23
D 27
	sc->acc_ifuba.ifu_ubareset = accreset;
E 27
E 23
I 16
D 25
	sc->acc_ifuba.ifu_flags = UBA_CANTWAIT;
E 25
I 25
D 28
	sc->acc_if->ifu_flags = UBA_CANTWAIT;
E 28
I 28
	sc->acc_ifuba.ifu_flags = UBA_CANTWAIT;
E 28
E 25
E 16
I 3
#ifdef notdef
D 14
	sc->acc_ifuba.ifu_flags = UBA_NEEDBDP;
E 14
I 14
D 16
	sc->acc_ifuba.ifu_flags = UBA_NEEDBDP | UBA_CANTWAIT;
E 16
I 16
	sc->acc_ifuba.ifu_flags |= UBA_NEEDBDP;
E 16
E 14
#endif
E 3
}

/*
 * Reset interface after UNIBUS reset.
 * If interface is on specified uba, reset its state.
 */
accreset(unit, uban)
	int unit, uban;
{
	register struct uba_device *ui;
	struct acc_softc *sc;

D 19
COUNT(ACCRESET);
E 19
	if (unit >= NACC || (ui = accinfo[unit]) == 0 || ui->ui_alive == 0 ||
	    ui->ui_ubanum != uban)
		return;
	printf(" acc%d", unit);
	sc = &acc_softc[unit];
I 36
D 43
	sc->acc_if->if_flags &= ~IFF_RUNNING;
E 43
I 43
	sc->acc_imp->imp_if.if_flags &= ~IFF_RUNNING;
I 45
	accoflush(unit);
E 45
E 43
E 36
	/* must go through IMP to allow it to set state */
D 43
	(*sc->acc_if->if_init)(unit);
E 43
I 43
	(*sc->acc_imp->imp_if.if_init)(sc->acc_imp->imp_if.if_unit);
E 43
}

/*
 * Initialize interface: clear recorded pending operations,
D 3
 * and retrieve, and reinitialize UNIBUS resources.
E 3
I 3
 * and retrieve, and initialize UNIBUS resources.  Note
 * return value is used by IMP init routine to mark IMP
 * unavailable for outgoing traffic.
E 3
 */
accinit(unit)
	int unit;
{	
D 3
	register struct acc_softc *sc = &acc_softc[unit];
	register struct uba_device *ui = accinfo[unit];
E 3
I 3
	register struct acc_softc *sc;
	register struct uba_device *ui;
E 3
	register struct accdevice *addr;
D 12
	int x, info;
E 12
I 12
D 22
	int info, i;
E 22
I 22
	int info;
E 22
E 12

D 19
COUNT(ACCINIT);
E 19
D 3
	if (if_ubainit(&sc->acc_ifuba, ui->ui_ubanum,
	      sizeof(struct imp_leader), (int)btop(IMP_MTU)) == 0) {
E 3
I 3
	if (unit >= NACC || (ui = accinfo[unit]) == 0 || ui->ui_alive == 0) {
		printf("acc%d: not alive\n", unit);
		return (0);
	}
	sc = &acc_softc[unit];
	/*
	 * Header length is 0 since we have to passs
	 * the IMP leader up to the protocol interpretation
	 * routines.  If we had the header length as
	 * sizeof(struct imp_leader), then the if_ routines
	 * would asssume we handle it on input and output.
	 */
D 9
	if (if_ubainit(&sc->acc_ifuba, ui->ui_ubanum, 0, btoc(IMP_MTU)) == 0) {
E 9
I 9
D 43
	if (if_ubainit(&sc->acc_ifuba, ui->ui_ubanum, 0,
D 11
	     (int)btoc(IMP_MTU)) == 0) {
E 11
I 11
D 40
	     (int)btoc(IMPMTU)) == 0) {
E 40
I 40
	     (int)btoc(IMPMTU+2)) == 0) {
E 43
I 43
	if ((sc->acc_imp->imp_if.if_flags & IFF_RUNNING) == 0 &&
	    if_ubainit(&sc->acc_ifuba, ui->ui_ubanum, 0,
	     (int)btoc(IMP_RCVBUF)) == 0) {
E 43
E 40
E 11
E 9
E 3
		printf("acc%d: can't initialize\n", unit);
D 3
		return;
E 3
I 3
D 16
		goto down;
E 16
I 16
D 45
		ui->ui_alive = 0;
E 45
I 39
D 43
		sc->acc_if->if_flags &= ~(IFF_UP | IFF_RUNNING);
E 43
I 43
		sc->acc_imp->imp_if.if_flags &= ~(IFF_UP | IFF_RUNNING);
E 43
E 39
		return (0);
E 16
E 3
	}
I 36
D 43
	sc->acc_if->if_flags |= IFF_RUNNING;
E 43
I 43
	sc->acc_imp->imp_if.if_flags |= IFF_RUNNING;
E 43
E 36
	addr = (struct accdevice *)ui->ui_addr;

D 2
	/* reset the imp interface. */
E 2
I 2
	/*
D 3
	 * Reset the imp interface.
	 * the delays are totally guesses
E 3
I 3
	 * Reset the imp interface;
	 * the delays are pure guesswork.
E 3
	 */
E 2
D 12
	x = spl5();
E 12
D 3
	addr->acc_icsr = ACC_RESET;
I 2
	DELAY(100);
E 2
        addr->acc_ocsr = ACC_RESET;
I 2
	DELAY(1000);
E 2
	addr->acc_ocsr = OUT_BBACK;	/* reset host master ready */
I 2
	DELAY(1000);
E 2
	addr->acc_ocsr = 0;
	addr->acc_icsr = IN_MRDY;	/* close the relay */
E 3
I 3
D 16
	addr->icsr = ACC_RESET; DELAY(5000);
E 16
        addr->ocsr = ACC_RESET; DELAY(5000);
D 10
	addr->ocsr = OUT_BBACK;	DELAY(1000);	/* reset host master ready */
E 10
I 10
	addr->ocsr = OUT_BBACK;	DELAY(5000);	/* reset host master ready */
E 10
	addr->ocsr = 0;
E 3
D 12
	splx(x);
E 12
I 3
D 6
	addr->icsr = IN_MRDY;			/* close the relay */
E 3

E 6
I 6
D 16
	addr->icsr = IN_MRDY | IN_WEN;		/* close the relay */
D 10
	DELAY(5000);
E 10
I 10
	DELAY(10000);
E 10
E 6
	/* YECH!!! */
D 3
	while ((addr->acc_icsr & IN_HRDY) == 0 ||
	       (addr->acc_icsr & (IN_RMR | IN_IMPBSY))) {
		/* keep turning IN_RMR off */
		addr->acc_icsr = IN_MRDY;
D 2
		sleep((caddr_t)&lbolt, PZERO);
E 2
I 2
		sleep((caddr_t)&lbolt, PZERO);	/* ??? */
E 3
I 3
D 12
	x = 500;
	while (x-- > 0) {
E 12
I 12
	for (i = 0; i < 500; i++) {
E 12
		if ((addr->icsr & IN_HRDY) ||
D 8
		    (addr->icsr & (IN_RMR | IN_IMPBSY) == 0))
E 8
I 8
		    (addr->icsr & (IN_RMR | IN_IMPBSY)) == 0)
E 8
D 12
			break;
E 12
I 12
			goto ok;
E 12
D 6
		addr->icsr = IN_MRDY; DELAY(5000); /* keep turning IN_RMR off */
E 6
I 6
D 10
		addr->icsr = IN_MRDY | IN_WEN;
		DELAY(5000);			/* keep turning IN_RMR off */
E 10
I 10
		addr->icsr = IN_MRDY | IN_WEN; DELAY(10000);
		/* keep turning IN_RMR off */
E 16
I 16
	if (accinputreset(addr, unit) == 0) {
		ui->ui_alive = 0;
		return (0);
E 16
E 10
E 6
E 3
E 2
	}
I 3
D 12
	if (x <= 0) {
		printf("acc%d: imp doesn't respond, icsr=%b\n", unit,
			addr->icsr, ACC_INBITS);
		goto down;
	}
E 12
I 12
D 16
	printf("acc%d: imp doesn't respond, icsr=%b\n", unit,
		addr->icsr, ACC_INBITS);
down:
	ui->ui_alive = 0;
	return (0);
E 16
E 12
E 3

I 12
D 16
ok:
E 16
E 12
	/*
	 * Put up a read.  We can't restart any outstanding writes
	 * until we're back in synch with the IMP (i.e. we've flushed
	 * the NOOPs it throws at us).
I 3
D 11
	 * Note: IMP_MTU includes the leader.
E 11
I 11
D 43
	 * Note: IMPMTU includes the leader.
E 43
I 43
	 * Note: IMP_RCVBUF includes the leader.
E 43
E 11
E 3
	 */
I 16
D 18
	acctrace("init", addr->icsr);
E 18
E 16
D 12
	x = spl5();
E 12
	info = sc->acc_ifuba.ifu_r.ifrw_info;
D 3
	addr->acc_iba = (u_short)info;
	addr->acc_iwc = -(sizeof(struct imp_leader) + IMP_MTU) >> 1;
	addr->acc_icsr = 
E 3
I 3
	addr->iba = (u_short)info;
D 11
	addr->iwc = -(IMP_MTU >> 1);
E 11
I 11
D 40
	addr->iwc = -(IMPMTU >> 1);
E 40
I 40
D 43
	addr->iwc = -((IMPMTU + 2) >> 1);
E 43
I 43
	addr->iwc = -((IMP_RCVBUF) >> 1);
E 43
E 40
E 11
#ifdef LOOPBACK
	addr->ocsr |= OUT_BBACK;
#endif
	addr->icsr = 
E 3
		IN_MRDY | ACC_IE | IN_WEN | ((info & 0x30000) >> 12) | ACC_GO;
D 12
	splx(x);
E 12
I 3
	return (1);
D 12
down:
	ui->ui_alive = 0;
	return (0);
E 12
E 3
}

I 16
accinputreset(addr, unit)
	register struct accdevice *addr;
	register int unit;
{
	register int i;

	addr->icsr = ACC_RESET; DELAY(5000);
	addr->icsr = IN_MRDY | IN_WEN;		/* close the relay */
	DELAY(10000);
	/* YECH!!! */
	for (i = 0; i < 500; i++) {
		if ((addr->icsr & IN_HRDY) ||
		    (addr->icsr & (IN_RMR | IN_IMPBSY)) == 0)
			return (1);
		addr->icsr = IN_MRDY | IN_WEN; DELAY(10000);
		/* keep turning IN_RMR off */
	}
	printf("acc%d: imp doesn't respond, icsr=%b\n", unit,
		addr->icsr, ACC_INBITS);
	return (0);
}

E 16
/*
I 43
 * Drop the host ready line to mark host down.
 */
accdown(unit)
	int unit;
{
	register struct accdevice *addr;

	addr = (struct accdevice *)(accinfo[unit]->ui_addr);
        addr->ocsr = ACC_RESET;
	DELAY(5000);
	addr->ocsr = OUT_BBACK;		/* reset host master ready */
I 45
	accoflush(unit);
E 45
	return (1);
I 45
}

accoflush(unit)
	int unit;
{
	register struct acc_softc *sc = &acc_softc[unit];

	sc->acc_imp->imp_cb.ic_oactive = 0;
	if (sc->acc_ifuba.ifu_xtofree) {
		m_freem(sc->acc_ifuba.ifu_xtofree);
		sc->acc_ifuba.ifu_xtofree = 0;
	}
E 45
}

/*
E 43
 * Start output on an interface.
 */
D 43
accstart(dev)
	dev_t dev;
E 43
I 43
accoutput(unit, m)
	int unit;
	struct mbuf *m;
E 43
{
D 43
	int unit = ACCUNIT(dev), info;
E 43
I 43
	int info;
E 43
D 5
	struct uba_device *ui = accinfo[unit];
E 5
	register struct acc_softc *sc = &acc_softc[unit];
	register struct accdevice *addr;
D 43
	struct mbuf *m;
E 43
I 3
D 5
	struct imp_leader *ip;
E 5
E 3
	u_short cmd;

D 19
COUNT(ACCSTART);
E 19
I 16
D 18
	acctrace("start", sc->acc_ic->ic_oactive);
E 18
E 16
I 3
D 4
printf("accstart: active=%d\n", sc->acc_ic->ic_oactive);
E 4
E 3
D 43
	if (sc->acc_ic->ic_oactive)
		goto restart;
	
	/*
	 * Not already active, deqeue a request and
	 * map it onto the UNIBUS.  If no more
	 * requeusts, just return.
	 */
	IF_DEQUEUE(&sc->acc_if->if_snd, m);
I 3
D 4
printf("accstart: dequeue m=%x\n", m);
E 4
E 3
	if (m == 0) {
I 16
D 18
		acctrace("q empty", 0);
E 18
E 16
		sc->acc_ic->ic_oactive = 0;
		return;
	}
E 43
	sc->acc_olen = if_wubaput(&sc->acc_ifuba, m);
I 3
D 4
printf("accstart: olen=%d\n", sc->acc_olen);
E 4
E 3
D 43

restart:
E 43
	/*
D 3
	 * Have request mapped to UNIBUS for transmission.
	 * Purge any stale data from the BDP, and start the output.
E 3
I 3
	 * Have request mapped to UNIBUS for
	 * transmission; start the output.
E 3
	 */
D 3
	UBAPURGE(sc->acc_ifuba.ifu_uba, sc->acc_ifuba.ifu_w.ifrw_bdp);
E 3
I 3
	if (sc->acc_ifuba.ifu_flags & UBA_NEEDBDP)
		UBAPURGE(sc->acc_ifuba.ifu_uba, sc->acc_ifuba.ifu_w.ifrw_bdp);
E 3
D 5
	addr = (struct accdevice *)ui->ui_addr;
E 5
I 5
	addr = (struct accdevice *)accinfo[unit]->ui_addr;
E 5
	info = sc->acc_ifuba.ifu_w.ifrw_info;
D 3
	addr->acc_oba = (u_short)info;
	addr->acc_owc = -((sc->acc_olen + 1) >> 1);
E 3
I 3
	addr->oba = (u_short)info;
	addr->owc = -((sc->acc_olen + 1) >> 1);
E 3
	cmd = ACC_IE | OUT_ENLB | ((info & 0x30000) >> 12) | ACC_GO;
D 3
	addr->acc_ocsr = cmd;
E 3
I 3
#ifdef LOOPBACK
	cmd |= OUT_BBACK;
#endif
	addr->ocsr = cmd;
E 3
D 43
	sc->acc_ic->ic_oactive = 1;
E 43
I 43
	sc->acc_imp->imp_cb.ic_oactive = 1;
E 43
}

/*
 * Output interrupt handler.
 */
accxint(unit)
I 20
	int unit;
E 20
{
D 5
	register struct uba_device *ui = accinfo[unit];
E 5
	register struct acc_softc *sc = &acc_softc[unit];
	register struct accdevice *addr;

D 19
COUNT(ACCXINT);
E 19
I 16
D 18
	acctrace("xint", sc->acc_ic->ic_oactive);
E 18
	addr = (struct accdevice *)accinfo[unit]->ui_addr;
E 16
D 43
	if (sc->acc_ic->ic_oactive == 0) {
E 43
I 43
	if (sc->acc_imp->imp_cb.ic_oactive == 0) {
E 43
D 2
		printf("acc%d: stray output interrupt\n", unit);
E 2
I 2
D 3
		printf("acc%d: stray send interrupt\n", unit);
E 3
I 3
D 16
		printf("acc%d: stray xmit interrupt\n", unit);
E 16
I 16
		printf("acc%d: stray xmit interrupt, csr=%b\n", unit,
			addr->ocsr, ACC_OUTBITS);
D 17
		addr->ocsr  = ACC_RESET; 
E 17
E 16
E 3
E 2
		return;
	}
D 5
	addr = (struct accdevice *)ui->ui_addr;
E 5
I 5
D 16
	addr = (struct accdevice *)accinfo[unit]->ui_addr;
E 16
I 16
D 18
	acctrace("ocsr", addr->ocsr);
E 18
E 16
E 5
I 3
D 4
printf("accxint: ocsr=%b\n", addr->ocsr, ACC_OUTBITS);
E 4
E 3
D 43
	sc->acc_if->if_opackets++;
	sc->acc_ic->ic_oactive = 0;
E 43
I 43
	sc->acc_imp->imp_if.if_opackets++;
	sc->acc_imp->imp_cb.ic_oactive = 0;
E 43
D 2
	if (addr->acc_ocsr & ACC_ERR)
		printf("acc%d: output error, csr=%b\n", unit,
E 2
I 2
D 3
	if (addr->acc_ocsr & ACC_ERR) {
		printf("acc%d: send error, csr=%b\n", unit,
E 2
			addr->acc_ocsr, ACC_OUTBITS);
E 3
I 3
D 16
	if (addr->ocsr & ACC_ERR) {
		printf("acc%d: output error, csr=%b\n", unit,
			addr->ocsr, ACC_OUTBITS);
E 16
I 16
D 17
	if (addr->ocsr & (ACC_ERR|OUT_TMR)) {
E 17
I 17
	if (addr->ocsr & ACC_ERR) {
E 17
		printf("acc%d: output error, ocsr=%b, icsr=%b\n", unit,
			addr->ocsr, ACC_OUTBITS, addr->icsr, ACC_INBITS);
E 16
E 3
D 2
	if (sc->acc_if->if_snd.ifq_head == 0) {
E 2
D 43
		sc->acc_if->if_oerrors++;
E 43
I 43
		sc->acc_imp->imp_if.if_oerrors++;
E 43
I 2
	}
D 3
	if (sc->acc_if->if_snd.ifq_head == 0) {
E 2
		if (sc->acc_ifuba.ifu_xtofree) {
			m_freem(sc->acc_ifuba.ifu_xtofree);
			sc->acc_ifuba.ifu_xtofree = 0;
		}
		return;
E 3
I 3
	if (sc->acc_ifuba.ifu_xtofree) {
		m_freem(sc->acc_ifuba.ifu_xtofree);
		sc->acc_ifuba.ifu_xtofree = 0;
E 3
	}
I 3
D 4
	if (sc->acc_if->if_snd.ifq_head == 0)
		return;
E 3
	accstart(unit);
E 4
I 4
D 17
	if (sc->acc_if->if_snd.ifq_head)
		accstart(unit);
E 17
I 17
D 18
	if (sc->acc_if->if_snd.ifq_head == 0) {
		addr->ocsr &= ~ACC_IE;		/* hardware funky? */
		return;
	}
	accstart(unit);
E 18
I 18
D 43
	if (sc->acc_if->if_snd.ifq_head)
		accstart(unit);
E 43
I 43
	impstart(sc->acc_imp);
E 43
E 18
E 17
E 4
}

/*
 * Input interrupt handler
 */
accrint(unit)
I 20
	int unit;
E 20
{
	register struct acc_softc *sc = &acc_softc[unit];
	register struct accdevice *addr;
D 9
	register struct ifqueue *inq;
E 9
    	struct mbuf *m;
	int len, info;

D 19
COUNT(ACCRINT);
E 19
I 16
	addr = (struct accdevice *)accinfo[unit]->ui_addr;
D 17
	if ((addr->icsr & ACC_RDY) == 0) {
		printf("acc%d: stray input interrupt\n", unit);
		accinputreset(addr, unit);
		goto setup;
	}
E 17
E 16
D 43
	sc->acc_if->if_ipackets++;
E 43
I 43
	sc->acc_imp->imp_if.if_ipackets++;
E 43

	/*
	 * Purge BDP; flush message if error indicated.
	 */
D 3
	UBAPURGE(sc->acc_ifuba.ifu_uba, sc->acc_ifuba.ifu_r.ifrw_bdp);
E 3
I 3
	if (sc->acc_ifuba.ifu_flags & UBA_NEEDBDP)
		UBAPURGE(sc->acc_ifuba.ifu_uba, sc->acc_ifuba.ifu_r.ifrw_bdp);
E 3
D 16
	addr = (struct accdevice *)accinfo[unit]->ui_addr;
D 3
	if (addr->acc_icsr & ACC_ERR) {
		printf("acc%d: recv error, csr=%b\n", unit,
		    addr->acc_icsr, ACC_INBITS);
E 3
I 3
D 4
printf("accrint: icsr=%b, flush=%d\n", addr->icsr, ACC_INBITS, sc->acc_flush);
E 4
	if (addr->icsr & ACC_ERR) {
		printf("acc%d: input error, csr=%b\n", unit,
		    addr->icsr, ACC_INBITS);
E 16
I 16
D 18
	acctrace("rint", addr->icsr);
E 18
D 17
	if (addr->icsr & (ACC_ERR|IN_RMR)) {
E 17
I 17
	if (addr->icsr & ACC_ERR) {
E 17
D 18
		printf("acc%d: input error, icsr=%b, ocsr=%b\n", unit,
		    addr->icsr, ACC_INBITS, addr->ocsr, ACC_OUTBITS);
E 18
I 18
		printf("acc%d: input error, csr=%b\n", unit,
		    addr->icsr, ACC_INBITS);
E 18
E 16
E 3
D 43
		sc->acc_if->if_ierrors++;
E 43
I 43
		sc->acc_imp->imp_if.if_ierrors++;
E 43
I 16
D 17
		if (addr->icsr & IN_RMR)
			accinputreset(addr, unit);
E 17
E 16
		sc->acc_flush = 1;
	}

I 16
D 18
	acctrace("flush", sc->acc_flush);
E 18
E 16
	if (sc->acc_flush) {
D 3
		if (addr->acc_icsr & IN_EOM)
E 3
I 3
		if (addr->icsr & IN_EOM)
E 3
			sc->acc_flush = 0;
		goto setup;
	}
D 3
	len = sizeof(struct imp_leader) + (addr->acc_iwc << 1);
E 3
I 3
D 11
	len = IMP_MTU + (addr->iwc << 1);
D 4
printf("accrint: len=%d\n", len);
E 4
	if (len < 0 || len > IMP_MTU) {
E 11
I 11
D 40
	len = IMPMTU + (addr->iwc << 1);
I 16
D 18
	acctrace("length", len);
E 18
E 16
	if (len < 0 || len > IMPMTU) {
E 11
		printf("acc%d: bad length=%d\n", len);
E 40
I 40
D 43
	len = IMPMTU+2 + (addr->iwc << 1);
	if (len < 0 || len > IMPMTU+2) {
E 43
I 43
	len = IMP_RCVBUF + (addr->iwc << 1);
	if (len < 0 || len > IMP_RCVBUF) {
E 43
		printf("acc%d: bad length=%d\n", unit, len);
E 40
D 43
		sc->acc_if->if_ierrors++;
E 43
I 43
		sc->acc_imp->imp_if.if_ierrors++;
E 43
		goto setup;
	}
E 3

	/*
D 39
	 * The last parameter is always 0 since using
E 39
I 39
	 * The offset parameter is always 0 since using
E 39
	 * trailers on the ARPAnet is insane.
	 */
D 39
	m = if_rubaget(&sc->acc_ifuba, len, 0);
E 39
I 39
D 41
	m = if_rubaget(&sc->acc_ifuba, len, 0, &sc->acc_if);
E 41
I 41
D 43
	m = if_rubaget(&sc->acc_ifuba, len, 0, sc->acc_if);
E 43
I 43
	m = if_rubaget(&sc->acc_ifuba, len, 0, &sc->acc_imp->imp_if);
E 43
E 41
E 39
I 3
D 4
printf("accrint: m=%x\n", m);
E 4
E 3
	if (m == 0)
		goto setup;
D 3
	if ((addr->acc_icsr & IN_EOM) == 0) {
E 3
I 3
	if ((addr->icsr & IN_EOM) == 0) {
E 3
D 2
		if (sc->acc_previous)
E 2
I 2
		if (sc->acc_iq)
E 2
			m_cat(sc->acc_iq, m);
D 2
		else {
E 2
I 2
		else
E 2
			sc->acc_iq = m;
D 2
			sc->acc_previous = 1;
		}
E 2
		goto setup;
	}
D 5
	/* adjust message length for padding. */
E 5
I 3
D 7
#ifdef notdef
I 5
	/* adjust message length for padding. */
E 5
E 3
	m->m_len -= 2;
I 3
#endif
E 7
E 3
D 2
	if (sc->acc_previous) {
E 2
I 2
	if (sc->acc_iq) {
E 2
		m_cat(sc->acc_iq, m);
		m = sc->acc_iq;
		sc->acc_iq = 0;
D 2
		sc->acc_previous = 0;
E 2
	}
I 16
D 18
	acctrace("impinput", 0);
E 18
E 16
	impinput(unit, m);

setup:
	/*
	 * Setup for next message.
	 */
	info = sc->acc_ifuba.ifu_r.ifrw_info;
D 3
	addr->acc_iba = (u_short)info;
	addr->acc_iwc = - (sizeof(struct imp_leader) + IMP_MTU) >> 1;
	addr->acc_icsr =
E 3
I 3
	addr->iba = (u_short)info;
D 11
	addr->iwc = -(IMP_MTU >> 1);
E 11
I 11
D 40
	addr->iwc = -(IMPMTU >> 1);
E 40
I 40
D 43
	addr->iwc = -((IMPMTU + 2)>> 1);
E 43
I 43
	addr->iwc = -((IMP_RCVBUF)>> 1);
E 43
E 40
E 11
	addr->icsr =
E 3
		IN_MRDY | ACC_IE | IN_WEN | ((info & 0x30000) >> 12) | ACC_GO;
I 16
D 18
}

int	accprintf = 0;

acctrace(cmd, value)
	char *cmd;
	int value;
{
	register int i;
	register char *p = (char *)&value;

	if (accprintf)
		printf("%s: %x", cmd, value);
	do {
		if (accdebugx >= NACCDEBUG)
			accdebugx = 0;
		accdebug[accdebugx++] = *cmd;
	} while (*cmd++);
	for (i = 0; i < sizeof (int); i++) {
		if (accdebugx >= NACCDEBUG)
			accdebugx = 0;
		accdebug[accdebugx++] = *p++;
	}
E 18
E 16
}
#endif
E 1
