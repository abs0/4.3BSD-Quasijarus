h41375
s 00013/00008/00435
d D 7.2 87/02/19 17:34:02 karels 49 48
c pack labels
e
s 00001/00001/00442
d D 7.1 86/06/05 01:30:52 mckusick 48 47
c 4.3BSD release version
e
s 00001/00001/00442
d D 6.8 86/02/23 23:21:55 karels 47 46
c lint
e
s 00007/00010/00436
d D 6.7 86/02/02 21:41:19 karels 46 45
c retries restart from start of undone transfer
e
s 00010/00015/00436
d D 6.6 85/10/14 18:06:35 karels 45 44
c change error recovery procedure when starting positioning rather than
c retrying transfer (so attentions from other drives don't confuse us)
e
s 00006/00019/00445
d D 6.5 85/09/16 21:31:32 karels 44 43
c dkunit is gone; unifdef MTRDREV
e
s 00007/00001/00457
d D 6.4 85/06/08 14:07:48 mckusick 43 42
c Add copyright
e
s 00027/00000/00431
d D 6.3 84/09/25 11:26:53 mckusick 42 41
c TU78 error recovery (Griff Smith - ulysses!ggs)
e
s 00012/00012/00419
d D 6.2 84/08/29 21:43:55 bloom 41 39
c change to includes.  no more ../h
e
s 00013/00013/00418
d R 6.2 84/08/29 20:53:10 bloom 40 39
c change to includes.  no more ../h
e
s 00000/00000/00431
d D 6.1 83/07/29 07:34:58 sam 39 38
c 4.2 distribution
e
s 00000/00002/00431
d D 4.32 83/05/27 13:55:20 sam 38 37
c lint
e
s 00039/00019/00394
d D 4.31 83/05/18 02:25:53 sam 37 36
c later autoconf of tapes wasn't getting all info; also 
c autoconf swap devices if device comes on line late (more fixes for tu78 
c to follow) (first fix from mo@lbl-csam and ps@oklahoma)
e
s 00002/00001/00411
d D 4.30 82/12/17 12:09:40 sam 36 35
c sun merge
e
s 00004/00003/00408
d D 4.29 82/10/10 17:19:48 root 35 34
c vax header files in their place
e
s 00000/00000/00411
d D 4.28 82/08/22 21:17:38 root 34 33
c fully uio()'d
e
s 00000/00000/00411
d D 4.27 82/08/13 00:24:03 root 33 32
c hacks for chardev uio
e
s 00056/00006/00355
d D 4.26 82/04/11 19:37:41 sam 32 31
c mods from shannon to autoconfigure mba devices after boot
e
s 00014/00025/00347
d D 4.25 82/03/31 09:06:16 wnj 31 30
c clean up way pages are mapped
e
s 00001/00001/00371
d D 4.24 82/03/14 14:28:13 root 30 29
c #if 0 -> #if notdef
e
s 00002/00000/00370
d D 4.23 81/11/20 14:39:23 wnj 29 28
c more lint
e
s 00001/00001/00369
d D 4.22 81/11/07 10:39:36 wnj 28 27
c restore sccs keywords
e
s 00005/00001/00365
d D 4.21 81/11/07 10:38:22 wnj 27 26
c fixes from shannon
e
s 00008/00004/00358
d D 4.20 81/05/09 19:50:24 root 26 25
c start routine returns com (for tu78 eventually)
e
s 00003/00001/00359
d D 4.19 81/03/10 16:56:25 wnj 25 24
c ht typos; mba maintain dk_busy for seeks; up minor fixes; va and vp new working versions
e
s 00000/00000/00360
d D 4.18 81/03/09 01:53:29 wnj 24 23
c %G% -> %E%
e
s 00024/00042/00336
d D 4.17 81/03/08 20:12:45 wnj 23 22
c fixups just pre lint
e
s 00030/00012/00348
d D 4.16 81/03/07 14:28:08 wnj 22 21
c after attempt at ht driver at cc again; working with new 
c field names
e
s 00042/00052/00318
d D 4.15 81/03/06 23:14:21 wnj 21 20
c pre mass changes (still not working)
e
s 00013/00003/00357
d D 4.14 81/03/06 11:33:36 wnj 20 19
c new formats of error prints; mbainit 
c 
e
s 00006/00008/00354
d D 4.13 81/03/03 15:17:31 wnj 19 18
c working spin down/up
e
s 00016/00054/00346
d D 4.12 81/03/03 12:38:46 wnj 18 17
c further driver work... up now handles spin down; rest still dont
e
s 00000/00000/00400
d D 4.11 81/02/28 17:35:43 wnj 17 16
c rmalloc and related stuff
e
s 00003/00000/00397
d D 4.10 81/02/26 04:28:10 wnj 16 15
c cosmetic for new config and 750/780
e
s 00001/00000/00396
d D 4.9 81/02/25 21:02:44 wnj 15 14
c almost working versions
e
s 00000/00001/00396
d D 4.8 81/02/21 21:20:48 wnj 14 13
c first working uba interlockable version
e
s 00000/00000/00397
d D 4.7 81/02/19 21:58:17 wnj 13 12
c almost working ubago version (tm.c problems)
e
s 00000/00000/00397
d D 4.6 81/02/15 12:09:20 kre 12 11
c bootable autoconf version
e
s 00002/00002/00395
d D 4.5 81/02/10 16:06:20 kre 11 10
c first compiling autoconf version
e
s 00343/00044/00054
d D 4.4 81/02/08 18:32:26 wnj 10 9
c first working vorsion
e
s 00002/00000/00096
d D 4.3 80/12/17 10:39:42 wnj 9 8
c not yet on comet
e
s 00004/00004/00092
d D 4.2 80/11/09 22:54:40 bill 8 7
c minor lint
e
s 00000/00000/00096
d D 4.1 80/11/09 16:52:31 bill 7 6
c stamp for 4bsd
e
s 00027/00039/00069
d D 3.6 80/10/13 10:01:02 bill 6 5
c new monitoring; mba not pre-mapped
e
s 00000/00000/00108
d D 3.5 80/08/27 08:37:37 bill 5 4
c buffers allocated in sysmap, ioctls all take addresses
e
s 00032/00025/00076
d D 3.4 80/07/29 09:15:05 bill 4 3
c new mba stuff
e
s 00001/00001/00100
d D 3.3 80/06/07 02:46:16 bill 3 2
c %H%->%G%
e
s 00002/00002/00099
d D 3.2 80/04/30 17:15:58 bill 2 1
c fixed extern buffer because of new c botch
e
s 00101/00000/00000
d D 3.1 80/04/09 16:03:29 bill 1 0
c date and time created 80/04/09 16:03:29 by bill
e
u
U
t
T
I 1
D 3
/*	%M%	%I%	%H%	*/
E 3
I 3
D 10
/*	%M%	%I%	%G%	*/
E 10
I 10
D 27
/*	%M%	%I%	%E%	*/
E 27
I 27
D 28
/*	mba.c	4.21	81/10/27	*/
E 28
I 28
D 43
/*	%M%	%I%	%E%	*/
E 43
I 43
/*
D 48
 * Copyright (c) 1982 Regents of the University of California.
E 48
I 48
D 49
 * Copyright (c) 1982, 1986 Regents of the University of California.
E 49
I 49
 * Copyright (c) 1982 Regents of the University of California.
E 49
E 48
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	%W% (Berkeley) %G%
 */
E 43
E 28
E 27
E 10
E 3

I 16
#include "mba.h"
#if NMBA > 0
E 16
I 9
D 10
#if VAX==780
E 10
I 10
/*
D 18
 * Massbus driver; arbitrates massbusses through device driver routines
 * and provides common functions.
E 18
I 18
D 23
 * Massbus driver; arbitrates massbus using device
 * driver routines.  This module provides common functions.
E 23
I 23
 * Massbus driver, arbitrates a massbus among attached devices.
I 42
D 44
 *
 * OPTION:
 *	MTRDREV - Enable mag tape read backwards error recovery
E 44
E 42
E 23
E 18
 */
I 36
#include "../machine/pte.h"

E 36
D 18
int	mbadebug = 0;
#define	dprintf if (mbadebug) printf

E 18
E 10
E 9
D 41
#include "../h/param.h"
I 10
#include "../h/systm.h"
#include "../h/dk.h"
E 10
#include "../h/buf.h"
#include "../h/conf.h"
D 10
#include "../h/systm.h"
E 10
#include "../h/dir.h"
#include "../h/user.h"
#include "../h/proc.h"
D 10
#include "../h/seg.h"
#include "../h/pte.h"
E 10
#include "../h/map.h"
E 41
I 41
#include "param.h"
#include "systm.h"
D 49
#include "dk.h"
E 49
I 49
#include "dkstat.h"
E 49
#include "buf.h"
#include "conf.h"
#include "dir.h"
#include "user.h"
#include "proc.h"
#include "map.h"
E 41
I 10
D 36
#include "../h/pte.h"
E 36
E 10
D 22
#include "../h/mba.h"
E 22
I 22
D 35
#include "../h/mbareg.h"
#include "../h/mbavar.h"
E 22
#include "../h/mtpr.h"
E 35
I 35
#include "../vax/mtpr.h"
E 35
D 41
#include "../h/vm.h"
E 41
I 41
#include "vm.h"
E 41
I 35

D 41
#include "../vaxmba/mbareg.h"
#include "../vaxmba/mbavar.h"
E 41
I 41
#include "mbareg.h"
#include "mbavar.h"
E 41
E 35

I 44
/* mbunit should be the same as hpunit, etc.! */
#define mbunit(dev)	(minor(dev) >> 3)

E 44
I 15
D 23
char	mbasr_bits[] = MBASR_BITS;
E 23
I 23
char	mbsr_bits[] = MBSR_BITS;
E 23
E 15
/*
D 10
 * startup routine for MBA controllers.
E 10
I 10
 * Start activity on a massbus device.
D 22
 * We are given the device's mba_info structure and activate
E 22
I 22
 * We are given the device's mba_device structure and activate
E 22
 * the device via the unit start routine.  The unit start
 * routine may indicate that it is finished (e.g. if the operation
 * was a ``sense'' on a tape drive), that the (multi-ported) unit
 * is busy (we will get an interrupt later), that it started the
 * unit (e.g. for a non-data transfer operation), or that it has
 * set up a data transfer operation and we should start the massbus adaptor.
E 10
 */
D 10
#define	MBAWCOM	0x30
#define	MBARCOM	0x38
#define	GO	01
E 10
I 10
mbustart(mi)
D 22
	register struct mba_info *mi;
E 22
I 22
	register struct mba_device *mi;
E 22
{
D 21
	register struct mba_drv *mdp;	/* drive registers */
E 21
	register struct buf *bp;	/* i/o operation at head of queue */
	register struct mba_hd *mhp;	/* header for mba device is on */
E 10

D 4
int mbaboff;
E 4
I 4
D 6
extern	char buffers[NBUF][BSIZE];
E 4

E 6
D 10
mbastart(bp, adcr)
E 10
I 10
D 18
	dprintf("enter mbustart\n");
E 18
loop:
	/*
	 * Get the first thing to do off device queue.
	 */
	bp = mi->mi_tab.b_actf;
	if (bp == NULL)
		return;
D 21
	mdp = mi->mi_drv;
E 21
	/*
I 32
D 45
	 * Make sure the drive is still there before starting it up.
	 */
	if ((mi->mi_drv->mbd_dt & MBDT_TYPE) == 0) {
		printf("%s%d: nonexistent\n", mi->mi_driver->md_dname,
D 44
		    dkunit(bp));
E 44
I 44
		    mbunit(bp->b_dev));
E 44
		mi->mi_alive = 0;
		mi->mi_tab.b_actf = bp->av_forw;
		mi->mi_tab.b_active = 0;
		mi->mi_tab.b_errcnt = 0;
		bp->b_flags |= B_ERROR;
		iodone(bp);
		goto loop;
	}
	/*
E 45
E 32
D 18
	 * Since we clear attentions on the drive when we are
	 * finished processing it, the fact that an attention
	 * status shows indicated confusion in the hardware or our logic.
	 */
	if (mdp->mbd_as & (1 << mi->mi_drive)) {
		printf("mbustart: ata on for %d\n", mi->mi_drive);
		mdp->mbd_as = 1 << mi->mi_drive;
	}
	/*
E 18
	 * Let the drivers unit start routine have at it
	 * and then process the request further, per its instructions.
	 */
	switch ((*mi->mi_driver->md_ustart)(mi)) {

	case MBU_NEXT:		/* request is complete (e.g. ``sense'') */
D 18
		dprintf("mbu_next\n");
E 18
		mi->mi_tab.b_active = 0;
I 21
		mi->mi_tab.b_errcnt = 0;
E 21
		mi->mi_tab.b_actf = bp->av_forw;
D 49
		iodone(bp);
E 49
I 49
		biodone(bp);
E 49
		goto loop;

	case MBU_DODATA:	/* all ready to do data transfer */
D 18
		dprintf("mbu_dodata\n");
E 18
		/*
D 22
		 * Queue the device mba_info structure on the massbus
E 22
I 22
		 * Queue the device mba_device structure on the massbus
E 22
		 * mba_hd structure for processing as soon as the
		 * data path is available.
		 */
		mhp = mi->mi_hd;
		mi->mi_forw = NULL;
		if (mhp->mh_actf == NULL)
			mhp->mh_actf = mi;
		else
			mhp->mh_actl->mi_forw = mi;
		mhp->mh_actl = mi;
		/*
		 * If data path is idle, start transfer now.
		 * In any case the device is ``active'' waiting for the
		 * data to transfer.
		 */
I 19
		mi->mi_tab.b_active = 1;
E 19
		if (mhp->mh_active == 0)
			mbstart(mhp);
D 19
		mi->mi_tab.b_active = 1;
E 19
		return;

	case MBU_STARTED:	/* driver started a non-data transfer */
D 18
		dprintf("mbu_started\n");
E 18
		/*
		 * Mark device busy during non-data transfer
		 * and count this as a ``seek'' on the device.
		 */
D 25
		if (mi->mi_dk >= 0)
E 25
I 25
		if (mi->mi_dk >= 0) {
E 25
			dk_seek[mi->mi_dk]++;
I 25
			dk_busy |= (1 << mi->mi_dk);
		}
E 25
		mi->mi_tab.b_active = 1;
		return;

	case MBU_BUSY:		/* dual port drive busy */
D 18
		dprintf("mbu_busy\n");
E 18
		/*
		 * We mark the device structure so that when an
		 * interrupt occurs we will know to restart the unit.
		 */
		mi->mi_tab.b_flags |= B_BUSY;
		return;

	default:
		panic("mbustart");
	}
D 11
#if VAX==780
E 11
I 11
}
E 11

/*
 * Start an i/o operation on the massbus specified by the argument.
 * We peel the first operation off its queue and insure that the drive
 * is present and on-line.  We then use the drivers start routine
 * (if any) to prepare the drive, setup the massbus map for the transfer
 * and start the transfer.
 */
mbstart(mhp)
	register struct mba_hd *mhp;
{
D 22
	register struct mba_info *mi;
E 22
I 22
	register struct mba_device *mi;
E 22
	struct buf *bp;
D 14
	register struct mba_drv *daddr;
E 14
	register struct mba_regs *mbp;
I 26
	register int com;
I 49
	extern int cold;
E 49
E 26

D 18
	dprintf("mbstart\n");
E 18
loop:
	/*
	 * Look for an operation at the front of the queue.
	 */
D 18
	if ((mi = mhp->mh_actf) == NULL) {
		dprintf("nothing to do\n");
E 18
I 18
D 21
	if ((mi = mhp->mh_actf) == NULL)
E 21
I 21
	if ((mi = mhp->mh_actf) == NULL) {
E 21
E 18
		return;
I 21
	}
E 21
D 18
	}
E 18
	if ((bp = mi->mi_tab.b_actf) == NULL) {
D 18
		dprintf("nothing on actf\n");
E 18
		mhp->mh_actf = mi->mi_forw;
		goto loop;
	}
	/*
	 * If this device isn't present and on-line, then
	 * we screwed up, and can't really do the operation.
I 27
	 * Only check for non-tapes because tape drivers check
	 * ONLINE themselves and because TU78 registers are
	 * different.
I 49
	 * No complaints during autoconfiguration,
	 * when we try to read disk labels from anything on line.
E 49
E 27
	 */
I 27
D 32
	if ((mi->mi_drv->mbd_dt & MBDT_TAP) == 0)
E 32
I 32
	if (((com = mi->mi_drv->mbd_dt) & MBDT_TAP) == 0)
E 32
E 27
D 23
	if ((mi->mi_drv->mbd_ds & (MBD_DPR|MBD_MOL)) != (MBD_DPR|MBD_MOL)) {
E 23
I 23
	if ((mi->mi_drv->mbd_ds & MBDS_DREADY) != MBDS_DREADY) {
E 23
D 18
		dprintf("not on line ds %x\n", mi->mi_drv->mbd_ds);
E 18
I 18
D 20
		printf("%c%d not ready\n", mi->mi_name, dkunit(bp));
E 20
I 20
D 22
		printf("%c%d: not ready\n", mi->mi_name, dkunit(bp));
E 22
I 22
D 32
		printf("%s%d: not ready\n", mi->mi_driver->md_dname,
		    dkunit(bp));
E 32
I 32
D 49
		if ((com & MBDT_TYPE) == 0) {
E 49
I 49
		if (!cold) {
		    if ((com & MBDT_TYPE) == 0) {
E 49
			mi->mi_alive = 0;
			printf("%s%d: nonexistent\n", mi->mi_driver->md_dname,
D 44
			    dkunit(bp));
E 44
I 44
			    mbunit(bp->b_dev));
E 44
D 49
		} else
E 49
I 49
		    } else
E 49
			printf("%s%d: not ready\n", mi->mi_driver->md_dname,
D 44
			    dkunit(bp));
E 44
I 44
			    mbunit(bp->b_dev));
I 49
		}
E 49
E 44
E 32
E 22
E 20
E 18
		mi->mi_tab.b_actf = bp->av_forw;
I 19
		mi->mi_tab.b_errcnt = 0;
		mi->mi_tab.b_active = 0;
E 19
		bp->b_flags |= B_ERROR;
D 49
		iodone(bp);
E 49
I 49
		biodone(bp);
E 49
		goto loop;
	}
	/*
	 * We can do the operation; mark the massbus active
	 * and let the device start routine setup any necessary
	 * device state for the transfer (e.g. desired cylinder, etc
	 * on disks).
	 */
	mhp->mh_active = 1;
D 18
	if (mi->mi_driver->md_start) {
		dprintf("md_start\n");
E 18
I 18
D 26
	if (mi->mi_driver->md_start)
E 18
		(*mi->mi_driver->md_start)(mi);
E 26
I 26
D 46
	if (mi->mi_driver->md_start) {
		if ((com = (*mi->mi_driver->md_start)(mi)) == 0)
			com = (bp->b_flags & B_READ) ?
			    MB_RCOM|MB_GO : MB_WCOM|MB_GO;
	} else
E 46
I 46
	if (mi->mi_driver->md_start == (int (*)())0 ||
	    (com = (*mi->mi_driver->md_start)(mi)) == 0)
E 46
		com = (bp->b_flags & B_READ) ? MB_RCOM|MB_GO : MB_WCOM|MB_GO;
E 26
D 18
	}
E 18

	/*
	 * Setup the massbus control and map registers and start
	 * the transfer.
	 */
D 18
	dprintf("start mba\n");
E 18
	mbp = mi->mi_mba;
	mbp->mba_sr = -1;	/* conservative */
I 42
D 44
#ifdef MTRDREV
E 44
	if (bp->b_bcount >= 0) {
D 46
		mbp->mba_var = mbasetup(mi);
		mbp->mba_bcr = -bp->b_bcount;
E 46
I 46
		mbp->mba_var = mbasetup(mi) + mi->mi_tab.b_bdone;
		mbp->mba_bcr = -(bp->b_bcount - mi->mi_tab.b_bdone);
E 46
	} else {
D 46
		mbp->mba_var = mbasetup(mi) - bp->b_bcount - 1;
		mbp->mba_bcr = bp->b_bcount;
E 46
I 46
		mbp->mba_var = mbasetup(mi) - bp->b_bcount - mi->mi_tab.b_bdone - 1;
		mbp->mba_bcr = bp->b_bcount + mi->mi_tab.b_bdone;
E 46
	}
D 44
#else
E 42
	mbp->mba_var = mbasetup(mi);
	mbp->mba_bcr = -bp->b_bcount;
I 42
#endif
E 44
E 42
D 26
	mi->mi_drv->mbd_cs1 =
D 23
	    (bp->b_flags & B_READ) ? MBD_RCOM|MBD_GO : MBD_WCOM|MBD_GO;
E 23
I 23
	    (bp->b_flags & B_READ) ? MB_RCOM|MB_GO : MB_WCOM|MB_GO;
E 26
I 26
	mi->mi_drv->mbd_cs1 = com;
E 26
E 23
	if (mi->mi_dk >= 0) {
		dk_busy |= 1 << mi->mi_dk;
		dk_xfer[mi->mi_dk]++;
I 42
D 44
#ifdef MTRDREV
E 44
		if (bp->b_bcount >= 0)
			dk_wds[mi->mi_dk] += bp->b_bcount >> 6;
		else
			dk_wds[mi->mi_dk] += -(bp->b_bcount) >> 6;
D 44
#else
E 42
		dk_wds[mi->mi_dk] += bp->b_bcount >> 6;
I 42
#endif
E 44
E 42
	}
}

/*
 * Take an interrupt off of massbus mbanum,
 * and dispatch to drivers as appropriate.
 */
mbintr(mbanum)
	int mbanum;
{
	register struct mba_hd *mhp = &mba_hd[mbanum];
	register struct mba_regs *mbp = mhp->mh_mba;
D 22
	register struct mba_info *mi;
E 22
I 22
	register struct mba_device *mi;
E 22
E 10
D 4
register struct buf *bp;
int *adcr;
E 4
I 4
	register struct buf *bp;
D 10
	int *adcr;
E 10
I 10
	register int drive;
D 21
	int mbastat, as;
E 21
I 21
	int mbasr, as;
I 32
	extern struct mba_device *mbaconfig();
I 37
D 38
	static mbaddtape();
E 38
E 37
E 32
E 21
	
	/*
	 * Read out the massbus status register
	 * and attention status register and clear
	 * the bits in same by writing them back.
	 */
D 21
	mbastat = mbp->mba_sr;
	mbp->mba_sr = mbastat;
E 21
I 21
	mbasr = mbp->mba_sr;
	mbp->mba_sr = mbasr;
E 21
I 18
#if VAX750
D 20
	if (mbastat&MBS_CBHUNG)
		panic("mba CBHUNG");
E 20
I 20
D 21
	if (mbastat&MBS_CBHUNG) {
E 21
I 21
D 23
	if (mbasr&MBS_CBHUNG) {
E 23
I 23
	if (mbasr&MBSR_CBHUNG) {
E 23
E 21
		printf("mba%d: control bus hung\n", mbanum);
		panic("cbhung");
	}
E 20
#endif
E 18
	/* note: the mbd_as register is shared between drives */
D 21
	as = mbp->mba_drv[0].mbd_as;
E 21
I 21
	as = mbp->mba_drv[0].mbd_as & 0xff;
E 21
	mbp->mba_drv[0].mbd_as = as;
D 18
	dprintf("mbintr mbastat %x as %x\n", mbastat, as);
E 18

	/*
D 23
	 * Disable interrupts from the massbus adapter
	 * for the duration of the operation of the massbus
	 * driver, so that spurious interrupts won't be generated.
	 */
	mbp->mba_cr &= ~MBAIE;

	/*
E 23
	 * If the mba was active, process the data transfer
	 * complete interrupt; otherwise just process units which
	 * are now finished.
	 */
	if (mhp->mh_active) {
D 19
		if ((mbastat & MBS_DTCMP) == 0) {
D 18
			printf("mbintr(%d),b_active,no DTCMP!\n", mbanum);
E 18
I 18
			printf("mb%d no DTCMP!\n", mbanum);
E 18
			goto doattn;
D 11
#include "../h/buf.h"
E 11
I 11
		}
E 19
E 11
		/*
		 * Clear attention status for drive whose data
D 23
		 * transfer completed, and give the dtint driver
E 23
I 23
		 * transfer related operation completed,
		 * and give the dtint driver
E 23
		 * routine a chance to say what is next.
		 */
		mi = mhp->mh_actf;
		as &= ~(1 << mi->mi_drive);
		dk_busy &= ~(1 << mi->mi_dk);
		bp = mi->mi_tab.b_actf;
D 21
		switch((*mi->mi_driver->md_dtint)(mi, mbastat)) {
E 21
I 21
D 23
		switch((*mi->mi_driver->md_dtint)(mi, mbasr)) {
E 23
I 23
		switch ((*mi->mi_driver->md_dtint)(mi, mbasr)) {
E 23
E 21

		case MBD_DONE:		/* all done, for better or worse */
D 18
			dprintf("mbd_done\n");
E 18
			/*
			 * Flush request from drive queue.
			 */
			mi->mi_tab.b_errcnt = 0;
			mi->mi_tab.b_actf = bp->av_forw;
D 49
			iodone(bp);
E 49
I 49
			biodone(bp);
E 49
			/* fall into... */
		case MBD_RETRY:		/* attempt the operation again */
D 18
			dprintf("mbd_retry\n");
E 18
			/*
			 * Dequeue data transfer from massbus queue;
			 * if there is still a i/o request on the device
			 * queue then start the next operation on the device.
			 * (Common code for DONE and RETRY).
			 */
			mhp->mh_active = 0;
			mi->mi_tab.b_active = 0;
			mhp->mh_actf = mi->mi_forw;
			if (mi->mi_tab.b_actf)
				mbustart(mi);
			break;

D 45
		case MBD_RESTARTED:	/* driver restarted op (ecc, e.g.)
E 45
I 45
		case MBD_REPOSITION:	/* driver started repositioning */
			/*
			 * Drive is repositioning, not doing data transfer.
			 * Free controller, but don't have to restart drive.
			 */
			mhp->mh_active = 0;
			mhp->mh_actf = mi->mi_forw;
			break;

		case MBD_RESTARTED:	/* driver restarted op (ecc, e.g.) */
E 45
D 18
			dprintf("mbd_restarted\n");
E 18
			/*
D 19
			 * Note that mp->b_active is still on.
E 19
I 19
			 * Note that mhp->mh_active is still on.
E 19
			 */
			break;

		default:
D 18
			panic("mbaintr");
E 18
I 18
			panic("mbintr");
E 18
		}
D 18
	} else {
		dprintf("!dtcmp\n");
		if (mbastat & MBS_DTCMP)
			printf("mbaintr,DTCMP,!b_active\n");
E 18
	}
D 21
doattn:
E 21
	/*
	 * Service drives which require attention
	 * after non-data-transfer operations.
	 */
D 21
	for (drive = 0; as && drive < 8; drive++)
		if (as & (1 << drive)) {
D 18
			dprintf("service as %d\n", drive);
E 18
			as &= ~(1 << drive);
			/*
			 * Consistency check the implied attention,
			 * to make sure the drive should have interrupted.
			 */
			mi = mhp->mh_mbip[drive];
D 18
			if (mi == NULL)
				goto random;		/* no such drive */
			if (mi->mi_tab.b_active == 0 &&
			    (mi->mi_tab.b_flags&B_BUSY) == 0)
				goto random;		/* not active */
			if ((bp = mi->mi_tab.b_actf) == NULL) {
							/* nothing doing */
random:
				printf("random mbaintr %d %d\n",mbanum,drive);
				continue;
			}
E 18
I 18
			if (mi == NULL || mi->mi_tab.b_active == 0 &&
			    (mi->mi_tab.b_flags&B_BUSY) == 0 ||
			    (bp = mi->mi_tab.b_actf) == NULL)
				continue;		/* unsolicited */
E 18
			/*
			 * If this interrupt wasn't a notification that
			 * a dual ported drive is available, and if the
			 * driver has a handler for non-data transfer
			 * interrupts, give it a chance to tell us that
			 * the operation needs to be redone
			 */
D 19
			if ((mi->mi_tab.b_flags&B_BUSY) == 0 &&
			    mi->mi_driver->md_ndint) {
E 19
I 19
			if (mi->mi_driver->md_ndint &&
			    (mi->mi_tab.b_flags&B_BUSY) == 0) {
E 19
				mi->mi_tab.b_active = 0;
				switch((*mi->mi_driver->md_ndint)(mi)) {
E 21
I 21
D 47
	while (drive = ffs(as)) {
E 47
I 47
	while (drive = ffs((long)as)) {
E 47
		drive--;		/* was 1 origin */
		as &= ~(1 << drive);
I 22
		mi = mhp->mh_mbip[drive];
D 32
		if (mi == NULL)
			continue;
E 32
I 32
		if (mi == NULL || mi->mi_alive == 0) {
			struct mba_device fnd;
D 37
			struct mba_slave *ms;
E 37
			struct mba_drv *mbd = &mhp->mh_mba->mba_drv[drive];
			int dt = mbd->mbd_dt & 0xffff;

			if (dt == 0 || dt == MBDT_MOH)
				continue;
			fnd.mi_mba = mhp->mh_mba;
			fnd.mi_mbanum = mbanum;
			fnd.mi_drive = drive;
			if ((mi = mbaconfig(&fnd, dt)) == NULL)
				continue;
D 37
			if (dt & MBDT_TAP) {
				for (ms = mbsinit; ms->ms_driver; ms++)
				if (ms->ms_driver == mi->mi_driver &&
				    ms->ms_alive == 0 && 
				    (ms->ms_ctlr == mi->mi_unit ||
				     ms->ms_ctlr == '?')) {
					if ((*ms->ms_driver->md_slave)(mi, ms)) {
						printf("%s%d at %s%d slave %d\n",
						    ms->ms_driver->md_sname,
						    ms->ms_unit,
						    mi->mi_driver->md_dname,
						    mi->mi_unit,
						    ms->ms_slave);
						ms->ms_alive = 1;
						ms->ms_ctlr = mi->mi_unit;
					}
				}
			}
E 37
I 37
			/*
			 * If a tape, poke the slave attach routines.
			 * Otherwise, could be a disk which we want
			 * to swap on, so make a pass over the swap
			 * configuration table in case the size of
			 * the swap area must be determined by drive type.
			 */
			if (dt & MBDT_TAP)
				mbaddtape(mi, drive);
			else
				swapconf();
E 37
		}
E 32
E 22
		/*
D 22
		 * driver has a handler for non-data transfer
E 22
I 22
		 * If driver has a handler for non-data transfer
E 22
D 23
		 * interrupts, give it a chance to tell us that
		 * the operation needs to be redone
E 23
I 23
		 * interrupts, give it a chance to tell us what to do.
E 23
		 */
D 22
		mi = mhp->mh_mbip[drive];
		if (mi == NULL)
			continue;
E 22
		if (mi->mi_driver->md_ndint) {
D 32
			mi->mi_tab.b_active = 0;
E 32
			switch ((*mi->mi_driver->md_ndint)(mi)) {
E 21

D 21
				case MBN_DONE:
D 18
					dprintf("mbn_done\n");
E 18
					/*
					 * Non-data transfer interrupt
					 * completed i/o request's processing.
					 */
					mi->mi_tab.b_errcnt = 0;
					mi->mi_tab.b_actf = bp->av_forw;
					iodone(bp);
					/* fall into... */
				case MBN_RETRY:
D 18
					dprintf("mbn_retry\n");
E 18
					if (mi->mi_tab.b_actf)
						mbustart(mi);
					break;
E 21
I 21
D 23
			case MBN_DONE:
				/*
				 * Non-data transfer interrupt
				 * completed i/o request's processing.
				 */
E 23
I 23
			case MBN_DONE:		/* operation completed */
I 32
				mi->mi_tab.b_active = 0;
E 32
E 23
				mi->mi_tab.b_errcnt = 0;
I 22
				bp = mi->mi_tab.b_actf;
E 22
				mi->mi_tab.b_actf = bp->av_forw;
D 49
				iodone(bp);
E 49
I 49
				biodone(bp);
E 49
D 23
				/* fall into... */
			case MBN_RETRY:
E 23
I 23
				/* fall into common code */
			case MBN_RETRY:		/* operation continues */
E 23
				if (mi->mi_tab.b_actf)
					mbustart(mi);
				break;
E 21
D 23

I 22
			case MBN_SKIP:
				/*
				 * Ignore (unsolicited interrupt, e.g.)
				 */
E 23
I 23
			case MBN_SKIP:		/* ignore unsol. interrupt */
E 23
				break;
D 23

			case MBN_CONT:
				/*
				 * Continue with unit active, e.g.
				 * between first and second rewind
				 * interrupts.
				 */
				mi->mi_tab.b_active = 1;
				break;

E 23
E 22
D 21
				default:
D 18
					panic("mbintr ndint");
E 18
I 18
					panic("mbintr");
E 18
				}
			} else
				mbustart(mi);
		}
E 21
I 21
			default:
				panic("mbintr");
			}
		} else
I 23
			/*
			 * If there is no non-data transfer interrupt
			 * routine, then we should just
			 * restart the unit, leading to a mbstart() soon.
			 */
E 23
			mbustart(mi);
	}
E 21
	/*
	 * If there is an operation available and
	 * the massbus isn't active, get it going.
	 */
	if (mhp->mh_actf && !mhp->mh_active)
		mbstart(mhp);
D 23
	mbp->mba_cr |= MBAIE;
E 23
I 23
	/* THHHHATS all folks... */
I 37
}

/*
 * For autoconfig'ng tape drives on the fly.
 */
D 38
static
E 38
mbaddtape(mi, drive)
	struct mba_device *mi;
	int drive;
{
	register struct mba_slave *ms;

	for (ms = mbsinit; ms->ms_driver; ms++)
		if (ms->ms_driver == mi->mi_driver && ms->ms_alive == 0 && 
		    (ms->ms_ctlr == mi->mi_unit ||
		     ms->ms_ctlr == '?')) {
			if ((*ms->ms_driver->md_slave)(mi, ms, drive)) {
				printf("%s%d at %s%d slave %d\n",
				    ms->ms_driver->md_sname,
				    ms->ms_unit,
				    mi->mi_driver->md_dname,
				    mi->mi_unit,
				    ms->ms_slave);
				ms->ms_alive = 1;
				ms->ms_ctlr = mi->mi_unit;
			}
		}
E 37
E 23
}

/*
 * Setup the mapping registers for a transfer.
 */
mbasetup(mi)
D 22
	register struct mba_info *mi;
E 22
I 22
	register struct mba_device *mi;
E 22
E 10
E 4
{
I 10
	register struct mba_regs *mbap = mi->mi_mba;
	struct buf *bp = mi->mi_tab.b_actf;
E 10
D 31
	register int i;
	int npf;
E 31
I 31
	register int npf;
E 31
	unsigned v;
	register struct pte *pte, *io;
	int o;
D 31
	int vaddr;
E 31
D 10
	register struct mba_regs *mbap;
E 10
	struct proc *rp;
D 4
	extern int mbanum[], *mbaloc[];
D 2
	extern char buffers[][];
E 2
I 2
	extern char buffers[NBUF][BSIZE];
E 4
E 2

D 4
	mbap = (struct mba_regs *)mbaloc[mbanum[major(bp->b_dev)]];
E 4
I 4
D 10
	mbap = mbainfo[mbanum[major(bp->b_dev)]].mi_loc;
E 10
E 4
D 6
	if ((bp->b_flags & B_PHYS) == 0)
D 4
		vaddr = (bp->b_un.b_addr - (char *)buffers) + mbaboff;
E 4
I 4
		vaddr = (bp->b_un.b_addr - buffers[0]);
E 4
	else {
D 4
		io = (struct pte *)mbap;
		io += (MBA_MAP + 128*4)/4;
E 4
I 4
		io = &mbap->mba_map[128];
E 4
		v = btop(bp->b_un.b_addr);
		o = (int)bp->b_un.b_addr & PGOFSET;
		npf = btoc(bp->b_bcount + o);
		rp = bp->b_flags&B_DIRTY ? &proc[2] : bp->b_proc;
		vaddr = (128 << 9) | o;
		if (bp->b_flags & B_UAREA) {
			for (i = 0; i < UPAGES; i++) {
				if (rp->p_addr[i].pg_pfnum == 0)
					panic("mba: zero upage");
				*(int *)io++ = rp->p_addr[i].pg_pfnum | PG_V;
			}
		} else if ((bp->b_flags & B_PHYS) == 0) {
			v &= 0x1fffff;		/* drop to physical addr */
			while (--npf >= 0)
				*(int *)io++ = v++ | PG_V;
		} else {
			if (bp->b_flags & B_PAGET)
				pte = &Usrptmap[btokmx((struct pte *)bp->b_un.b_addr)];
			else
				pte = vtopte(rp, v);
			while (--npf >= 0) {
				if (pte->pg_pfnum == 0)
					panic("mba, zero entry");
				*(int *)io++ = pte++->pg_pfnum | PG_V;
			}
E 6
I 6
D 31
	io = mbap->mba_map;
E 31
	v = btop(bp->b_un.b_addr);
D 46
	o = (int)bp->b_un.b_addr & PGOFSET;
E 46
I 46
	o = (int)(bp->b_un.b_addr) & PGOFSET;
E 46
I 42
D 44
#ifdef MTRDREV
E 44
	if (bp->b_bcount >= 0)
		npf = btoc(bp->b_bcount + o);
	else
		npf = btoc(-(bp->b_bcount) + o);
D 44
#else
E 42
	npf = btoc(bp->b_bcount + o);
I 42
#endif
E 44
E 42
	rp = bp->b_flags&B_DIRTY ? &proc[2] : bp->b_proc;
D 31
	vaddr = o;
	if (bp->b_flags & B_UAREA) {
		for (i = 0; i < UPAGES; i++) {
			if (rp->p_addr[i].pg_pfnum == 0)
				panic("mba: zero upage");
			*(int *)io++ = rp->p_addr[i].pg_pfnum | PG_V;
E 6
		}
I 6
	} else if ((bp->b_flags & B_PHYS) == 0) {
E 31
I 31
	if ((bp->b_flags & B_PHYS) == 0)
E 31
		pte = &Sysmap[btop(((int)bp->b_un.b_addr)&0x7fffffff)];
D 31
		while (--npf >= 0)
			*(int *)io++ = pte++->pg_pfnum | PG_V;
	} else {
		if (bp->b_flags & B_PAGET)
			pte = &Usrptmap[btokmx((struct pte *)bp->b_un.b_addr)];
		else
			pte = vtopte(rp, v);
		while (--npf >= 0) {
			if (pte->pg_pfnum == 0)
				panic("mba, zero entry");
			*(int *)io++ = pte++->pg_pfnum | PG_V;
		}
E 31
I 31
	else if (bp->b_flags & B_UAREA)
		pte = &rp->p_addr[v];
	else if (bp->b_flags & B_PAGET)
		pte = &Usrptmap[btokmx((struct pte *)bp->b_un.b_addr)];
	else
		pte = vtopte(rp, v);
	io = mbap->mba_map;
	while (--npf >= 0) {
		if (pte->pg_pfnum == 0)
			panic("mba, zero entry");
		*(int *)io++ = pte++->pg_pfnum | PG_V;
E 31
E 6
	}
I 6
	*(int *)io++ = 0;
E 6
D 10
	mbap->mba_sr = -1;	/* clear status (error) bits */
	mbap->mba_bcr = -bp->b_bcount;
	mbap->mba_var = vaddr;
	if (bp->b_flags & B_READ)
		*adcr = MBARCOM | GO;
	else
		*adcr = MBAWCOM | GO;
E 10
I 10
D 31
	return (vaddr);
E 31
I 31
	return (o);
E 31
I 20
}

I 29
D 30
#if 0
E 30
I 30
#if notdef
E 30
E 29
I 23
/*
 * Init and interrupt enable a massbus adapter.
 */
E 23
mbainit(mp)
	struct mba_regs *mp;
{

D 23
	mp->mba_cr = MBAINIT;
	mp->mba_cr = MBAIE;
E 23
I 23
	mp->mba_cr = MBCR_INIT;
	mp->mba_cr = MBCR_IE;
E 23
E 20
E 10
}
I 29
#endif
E 29
I 16
#endif
E 16
D 10

D 4
mbainit()
E 4
I 4
D 8
mbainit(mbanum)
	int mbanum;
E 8
I 8
mbainit(mbano)
	int mbano;
E 8
E 4
{
D 4
	register int *io0, *io1, *b, t, j;
	extern int *mbaloc[];
D 2
	extern char buffers[][];
E 2
I 2
	extern char buffers[NBUF][BSIZE];
E 4
I 4
D 6
	register struct pte *io, *b;
E 6
I 6
	register struct pte *b;
E 6
	register int i;
	register struct mba_info *mi;
	register struct mba_regs *mbap;
	unsigned v;
E 4
E 2

D 4
	io0 = mbaloc[0] + (MBA_MAP/4);
	io1 = mbaloc[1] + (MBA_MAP/4);
	b = (int *)Sysmap + ((((int) buffers)>>9)&PG_PFNUM);
	j = NBUF * CLSIZE + ((int)buffers & 0x1ff ? 1 : 0);
	do {
		t = PG_V | (*b++ & PG_PFNUM);
		*io0++ = t;
		*io1++ = t;
	} while (--j>0);
	*io0 = 0;		/* invalidate next entry */
	*io1 = 0;
	mbaboff = (int)buffers & 0x1ff;
E 4
I 4
D 8
	mi = &mbainfo[mbanum];
E 8
I 8
	mi = &mbainfo[mbano];
E 8
	v = btop((int)mi->mi_phys);
	b = mi->mi_map;
	for (i = 0; i < 8192; i += NBPG) {
		*(int *)b++ = PG_V | PG_KW | v;
		mtpr(TBIS, ptob(v));
		v++;
	}
	mbap = mi->mi_loc;
	mbap->mba_cr = MBAINIT;
	mbap->mba_cr = MBAIE;
D 6
	io = mbap->mba_map;
	b = &Sysmap[btop(((int)buffers[0])&0x7fffffff)];
	for (i = NBUF * CLSIZE; i > 0; i--) {
		*(int *)io++ = PG_V | b->pg_pfnum;
		b++;
	}
	*(int *)io = 0;
E 6
D 8
	mbaact |= (1<<mbanum);
E 8
I 8
	mbaact |= (1<<mbano);
E 8
E 4
}
I 9
#endif
E 10
E 9
E 1
