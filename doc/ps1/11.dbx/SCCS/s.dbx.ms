h42905
s 00058/00028/00397
d D 6.4 86/05/10 13:41:50 mckusick 4 3
c make it easier to change constant width fonts
e
s 00000/00009/00425
d D 6.3 86/05/07 19:01:50 kjd 3 2
c VAXinate the table
e
s 00069/00047/00365
d D 6.2 86/05/05 18:31:42 kjd 2 1
c VAXinate examples, clean up diction, and add acknowledgements
e
s 00412/00000/00000
d D 6.1 86/05/05 16:26:45 mckusick 1 0
c from UNIX REVIEW
e
u
U
t
T
I 1
.\"	%W% (Berkeley) %G%
.\"
D 2
\" modified by mark seiden in cosmetic ways.
\" dtbl | ditroff -ms
E 2
I 2
.\" modified by mark seiden in cosmetic ways.
.\" examples VAXinated by Kevin Dunlap
.\" dtbl | ditroff -ms
.OH 'Debugging with dbx''PS1:11-%'
.EH 'PS1:11-%''Debugging with dbx'
I 4
.de BE
.DS
.ft CW
.ps -1
..
.de EE
.ft P
.ps +1
.DE
..
.de UL
\f(CW\s-1\\$1\fP\s0
..
E 4
E 2
.TL
Debugging with dbx
.AU
Bill Tuthill
.AI
Sun Microsystems, Inc.
2550 Garcia Avenue
D 2
Mountain View, CA 94043
E 2
I 2
.AU
Kevin J. Dunlap
.AI
Computer Systems Research Group
University of California
Berkeley, CA 94720
E 2
.SH
Introduction
.PP
This short paper discusses
.I dbx ,
a symbolic debugger that is vastly superior to
.I adb .
D 2
In fact, it may be as good as the debuggers you remember from those
E 2
I 2
It may be as good as the debuggers you remember from those
E 2
non-
.UX 
systems you worked on before.
The advantage of symbolic debuggers is that they allow you
to work with the same names (symbols) as in your source code.
.PP
Like
.I adb ,
.I dbx
is interactive and line-oriented, but
.I dbx
is a source-level rather than an assembly-level debugger.
It allows you to determine where a program crashed,
to view the values of variables and expressions,
to set breakpoints in the code, and to run and trace a program.
Source code may be in C, Fortran, or Pascal.
.PP
Mark Linton wrote
.I dbx
as his master's thesis at UC Berkeley.
Along with Eric Schmidt's Berknet,
.I dbx
D 2
is one of the most successful master's theses done on UNIX.  Since
E 2
I 2
is among the most successful master's theses done on UNIX.  Since
E 2
.I dbx
required changes to the symbol tables
generated by the various compilers,
you need to compile programs for debugging with the
.I \-g
flag.  For example,
C programs should be compiled as follows:
.DS
% cc \-g \fIprogram\fP.c \-o \fIprogram\fP
.DE
Programs compiled with the
.I \-g
option have good symbol tables,
while programs compiled without
.I \-g
have old-style symbol tables intended for
.I adb .
Stripped programs have no symbol tables at all.
Invoke the debugger as follows, where
.I program
is the pathname of the executable file that dumped core:
.DS
% dbx \fIprogram\fP
.DE
The core image should be in the working directory;
if it isn't, specify its pathname in the argument after the program name.
D 2
One of the great advances of
E 2
I 2
Among the great advances of
E 2
.I dbx
is that it has a help facility; type the
.I help
request to see a list of possible requests.
You can obtain help on any
.I dbx
request by giving its name as an argument to
.I help .
.bp
.SH
Examining Core Dumps
.PP
Much of the time, programmers use
.I dbx
to find out why a program dumped core.
As an example, consider the following program
.I dumpcore.c ,
which dereferences a NULL pointer.
This is a legal operation on VAX/UNIX,
but not on VAX/VMS or on MC68000-based UNIX systems, on one of
which this example was run:
D 4
.DS
.ft CW
E 4
I 4
.BE
E 4
#include <stdio.h> 
.sp.5
#define LIMIT 5
.sp.5
main()			/* print messages and die */
{
	int i;
.sp.5
	for (i = 1; i <= 10 ; i++) {
		printf("Goodbye world! (%d)\en", i);
		dumpcore(i);
	}
	exit(0);
}
.sp.5
int *ip;
.sp.5
dumpcore(lim) 		/* dereference NULL pointer */
int lim;
{
	if (lim >= LIMIT)
		*ip = lim;
} 
D 4
.ft P
.DE
E 4
I 4
.EE
E 4
The program core dumps because of a
segmentation violation or memory fault \(em
on most machines it is illegal to assign to address zero.
Once the program has produced a core dump,
here's how you can find out why the program died:
.DS
D 4
% \f(CWdbx dumpcore\fP
E 4
I 4
%\c
.UL " dbx dumpcore"
E 4
D 2
Reading symbolic information...
Read 168 symbols
E 2
I 2
dbx version 3.17 of 4/24/86 15:04 (monet.Berkeley.EDU).
Type 'help' for help.
reading symbolic information ...
[using memory image in core]
E 2
D 4
(dbx) \f(CWwhere\fP
E 4
I 4
(dbx)\c
.UL " where"
E 4
D 2
dumpcore(lim = 5) at 0x80ef
main(0x1, 0xfffd84, 0xfffd8c), line 11 in "dumpcore.c"
E 2
I 2
dumpcore.dumpcore(lim = 5), line 22 in "dumpcore.c"
main(0x1, 0x7fffe904, 0x7fffe90c), line 11 in "dumpcore.c"
E 2
.DE
The
.I where
request yields a stack trace.
As you can see, the
.I dumpcore()
routine was called from line 11 of the program, with the argument
.I lim
equal to 5.
You can look at the
.I dumpcore()
procedure by invoking the
.I list
request as follows:
.DS
D 4
(dbx) \f(CWlist dumpcore\fP
E 4
I 4
(dbx)\c
.UL " list dumpcore"
E 4
   18   dumpcore(lim)           /* dereference NULL pointer */
   19   int lim;
   20   {
   21           if (lim >= LIMIT)
   22                   *ip = lim;
   23   }
.DE
We immediately suspect that the program's failure had something to do with
.I *ip ,
so we use the
.I print
request to retrieve the value of the pointer and what it points to:
.DS
D 4
(dbx) \f(CWprint *ip\fP
E 4
I 4
(dbx)\c
.UL " print *ip"
E 4
reference through nil pointer
D 4
(dbx) \f(CWprint ip\fP
E 4
I 4
(dbx)\c
.UL " print ip"
E 4
D 2
ip = (nil)
E 2
I 2
(nil)
E 2
.DE
This tells us the program has dereferenced a null pointer.
It is possible to run the program again from inside the debugger.
The first line tells you name of the running program,
and successive lines give output from the program:
.DS
D 4
(dbx) \f(CWrun\fP
E 4
I 4
(dbx)\c
.UL " run"
E 4
D 2
Running: dumpcore 
E 2
Goodbye world! (1)
Goodbye world! (2)
Goodbye world! (3)
Goodbye world! (4)
Goodbye world! (5)
.sp.5
D 2
segmentation violation in dumpcore at 0x80f0
000080f0        moveml  a6@(0),#<>
E 2
I 2
Bus error in dumpcore.dumpcore at line 22
   22		*ip = lim;
E 2
D 4
(dbx) \f(CWquit\fP
E 4
I 4
(dbx)\c
.UL " quit"
E 4
.DE
D 2
In this example the program dies with a segmentation violation, in a 
.I moveml
assembly instruction.
E 2
I 2
In this example the program dies with a Bus error at line 22. 
E 2
This method of running the program
does not produce a core dump, but the
.I where
request will still behave properly,
because the debugger is in the same state
as if it had just read the core file.
.SH
Setting Breakpoints
.PP
With
.I dbx
you can set breakpoints before each line of a program,
not just at function and procedure boundaries, as with
.I adb .
The
.I stop
request sets a breakpoint.
After setting a breakpoint, use the
.I run
request to execute the program.  The
.I cont
request continues execution from the current stopping point
until the program finishes or another breakpoint is encountered.  The
.I step
request executes one source statement,
following any function calls.  The
.I next
request executes one source statement,
but does not stop inside any function calls.  The
.I status
request lists active breakpoints, while the
.I delete
request removes them if required.
.PP
The
.I stop
request can take a conditional expression
D 2
in order to avoid needless single-stepping.
E 2
I 2
to avoid needless single-stepping.
E 2
We will use a conditional in our example to make things simpler.
Of course you can use
.I print
and
.I list
requests at any time during statement stepping
if you want to print the value of variables
or list lines of source code.
This sample session shows a mixture of requests
as we verify that the program fails when it tries to assign to
.I *ip :
.DS
D 4
(dbx) \f(CWstop at 10 if (i == 5)\fP
E 4
I 4
(dbx)\c
.UL " stop at 10 if (i == 5)"
E 4
D 2
(1) stop  at "dumpcore.c":10 if i == 5
E 2
I 2
[1] if i = 5 { stop } at 10
E 2
D 4
(dbx) \f(CWrun\fP
E 4
I 4
(dbx)\c
.UL " run"
E 4
D 2
Running: dumpcore 
E 2
Goodbye world! (1)
Goodbye world! (2)
Goodbye world! (3)
Goodbye world! (4)
D 2
stopped in main at line 10 in file "dumpcore.c"
   10                   printf("Goodbye world! (%d)\n", i);
E 2
I 2
[1] stopped in main at line 10
   10                   printf("Goodbye world! (%d)\en", i);
E 2
D 4
(dbx) \f(CWnext\fP
E 4
I 4
(dbx)\c
.UL " next"
E 4
Goodbye world! (5)
D 2
stopped in main at line 11 in file "dumpcore.c"
E 2
I 2
stopped in main at line 11
E 2
   11                   dumpcore(i);
D 4
(dbx) \f(CWstep\fP
E 4
I 4
(dbx)\c
.UL " step"
E 4
D 2
stopped in dumpcore at line 21 in file "dumpcore.c"
E 2
I 2
stopped in dumpcore at line 21
E 2
   21           if (lim >= LIMIT)
D 4
(dbx) \f(CWstep\fP
E 4
I 4
(dbx)\c
.UL " step"
E 4
D 2
stopped in dumpcore at line 22 in file "dumpcore.c"
E 2
I 2
stopped in dumpcore at line 22
E 2
   22                   *ip = lim;
D 4
(dbx) \f(CWstep\fP
E 4
I 4
(dbx)\c
.UL " step"
E 4
D 2
segmentation violation in dumpcore at 0x80f0
000080f0        moveml  a6@(0),#<>
E 2
I 2
Bus error in dumpcore.dumpcore at line 22
   22		*ip = lim;
E 2
.DE
Running the program with breakpoints assures us
that our intuition was correct.
We shouldn't be assigning anything to a null pointer \(em
.I ip
should have been initialized to point at an object of the proper type.
To exit from the debugger, use the
.I quit
request.
.PP
It is possible to set variables from inside
.I dbx .
The previous breakpoint session, for example,
could have gone like this:
.DS
D 4
% \f(CWdbx dumpcore\fP
E 4
I 4
%\c
.UL " dbx dumpcore"
E 4
D 2
Reading symbolic information...
Read 168 symbols
E 2
I 2
dbx version 3.17 of 4/24/86 15:04 (monet.Berkeley.EDU).
Type 'help' for help.
reading symbolic information ...
[using memory image in core]
E 2
D 4
(dbx) \f(CWstop at 10\fP
E 4
I 4
(dbx)\c
.UL " stop at 10"
E 4
D 2
(1) stop at "dumpcore.c":10
E 2
I 2
[1] stop at 10
E 2
D 4
(dbx) \f(CWrun\fP
E 4
I 4
(dbx)\c
.UL " run"
E 4
Running: dumpcore 
D 2
stopped in main at line 10 in file "dumpcore.c"
   10                   printf("Goodbye world! (%d)\n", i);
E 2
I 2
stopped in main at line 10
   10                   printf("Goodbye world! (%d)\en", i);
E 2
D 4
(dbx) \f(CWassign i = 5\fP
(dbx) \f(CWnext\fP
E 4
I 4
(dbx)\c
.UL " assign i = 5"
(dbx)\c
.UL " next"
E 4
Goodbye world! (5)
D 2
stopped in main at line 11 in file "dumpcore.c"
E 2
I 2
stopped in main at line 11
E 2
   11                   dumpcore(i);
D 4
(dbx) \f(CWnext\fP
E 4
I 4
(dbx)\c
.UL " next"
E 4
D 2
segmentation violation in dumpcore at 0x80f0
000080f0        moveml  a6@(0),#<>
E 2
I 2
Bus error in dumpcore.dumpcore at line 22
   22		*ip = lim;
E 2
.DE
It is often useful to assign new values to variables
D 2
in order to draw conclusions about alternative conditions.
E 2
I 2
to draw conclusions about alternative conditions.
E 2
We can't fix the bug in this program, however,
because there is no declared variable to which
.I ip
should point.
.SH
Conclusion
.PP
Expressions in
.I dbx
are similar to those in C,
except that there is a distinction between
.I /
(floating-point division) and
.I div
(integer division), as in Pascal.
The table on the following page shows
.I dbx
requests organized by function:
.PP
Like
.I adb ,
.I dbx
can disassemble object code.
It can also examine object files
and print output in various formats; but
.I dbx
requires the proper symbol tables, so
.I adb
is more useful to examine arbitrary binary files.
The most important thing
.I adb
can do that
.I dbx
cannot is to patch binary files \(em
.I dbx
has no write option.
Despite these shortcomings,
.I dbx
is much easier to use than
.I adb ,
so it contributes much more to individual programmer productivity.
I 2
.SH
Acknowledgements
.PP
Material presented in this document was first presented in
``C Advisor'', \fIUnix Review 4\fP, 1, pp 78\-85.
The Regents of the University California expresses their
gratitude to Unix Review
for allowing them to reprint this document.
.PP
This document is a good starting point for a more thorough tutorial.
Those with the ambition to expand on this document are encouraged
to contact the Computer Systems Research Group at ``4bsd-ideas@Berkeley.Edu.''
.KF
E 2
.TS
center box;
D 2
cfBI s.
E 2
I 2
cf s.
E 2
.sp.2
D 2
\s+2Groups of \&\fLdbx\fP Requests\s-2
E 2
I 2
\s+2Groups of \&\fIdbx\fP Requests\s-2
E 2
.sp.2
_
.T&
l lfI
D 4
lfCW l.
E 4
I 4
lp-1fCW l.
E 4
	execution and tracing
_
run	execute object file
cont	continue execution from where it stopped
trace	display tracing information at specified place
stop	stop execution at specified place
D 2
when	execute \&\fLdbx\fP requests at specified place
status	display active \&\fLtrace\fP and \&\fLstop\fP requests
delete	delete specific \&\fLtrace\fP or \&\fLstop\fP requests
E 2
I 2
D 3
when	execute \&\fIdbx\fP requests at specified place
E 3
status	display active \&\fItrace\fP and \&\fIstop\fP requests
delete	delete specific \&\fItrace\fP or \&\fIstop\fP requests
E 2
D 3
clear	clear all breakpoints
E 3
catch	start trapping specified signals
ignore	stop trapping specified signals
step	execute the next source line, stepping into functions
next	execute the next source line, even if it's a function
.T&
l lfI
D 4
lfCW l.
E 4
I 4
lp-1fCW l.
E 4
_
	displaying data
_
print	print the value of an expression
D 3
display	display the value of an expression at each stopping point
undisplay	don't display the value of an expression any more
E 3
whatis	print the declaration of a given identifier or type
which	print outer block associated with identifier
whereis	print all symbols matching identifier
assign	set the value of a variable
.T&
l lfI
D 4
lfCW l.
E 4
I 4
lp-1fCW l.
E 4
_
	function and procedure handling
_
where	display active procedures and functions on stack
down	move down the stack towards stopping point
D 2
up	move up the stack towards \&\fLmain\fP
E 2
I 2
up	move up the stack towards \&\fImain\fP
E 2
call	call the named function or procedure
dump	display names and values of all local variables
.T&
l lfI
D 4
lfCW l.
E 4
I 4
lp-1fCW l.
E 4
_
	accessing source files and directories
_
edit	invoke an editor on current source file
file	change current source file
func	change the current function or procedure
list	display lines of source code
use	set directory list to search for source files
D 2
cd	change \&\fLdbx\fP directory
pwd	print working \&\fLdbx\fP directory
E 2
I 2
D 3
cd	change \&\fIdbx\fP directory
pwd	print working \&\fIdbx\fP directory
E 3
E 2
/.../	search down in file to match regular expression
?...?	search up in file to match regular expression
.T&
l lfI
D 4
lfCW l.
E 4
I 4
lp-1fCW l.
E 4
_
	miscellaneous commands
_
sh	pass command line to the shell
D 2
alias	change \&\fLdbx\fP command name
E 2
I 2
alias	change \&\fIdbx\fP command name
E 2
help	explain commands
source	read commands from external file
D 2
dbxenv	set \&\fLdbx\fP environment
E 2
I 2
D 3
dbxenv	set \&\fIdbx\fP environment
E 2
debug	start debugging another object file
kill	terminate debugging of current program
E 3
quit	exit the debugger
.TE
D 2

E 2
I 2
.KE
.bp
E 2
E 1
