h48664
s 00020/00023/00902
d D 6.5 86/05/10 13:25:36 mckusick 5 4
c final update from karels
e
s 00041/00037/00884
d D 6.4 86/05/09 16:56:04 anne 4 3
c grammar, spelling
e
s 00155/00130/00766
d D 6.3 86/05/08 14:37:47 karels 3 2
c corrections and additions
e
s 00131/00169/00765
d D 6.2 86/05/06 17:11:12 mckusick 2 1
c formating cleanups for 4.3BSD documentation
e
s 00934/00000/00000
d D 6.1 86/05/02 12:18:22 mckusick 1 0
c original from sechrest
e
u
U
t
T
I 1
.\" Copyright (c) 1980 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
.\"
.\"	%W% (Berkeley) %G%
.\"
D 2
.he ``%``
.sp7
.b
E 2
I 2
.oh 'Introductory 4.3BSD IPC''PS1:7-%'
.eh 'PS1:7-%''Introductory 4.3BSD IPC'
D 3
.ps 12
E 3
I 3
.rs
.sp 2
.sz 14
E 3
.ft B
.ce 2
An Introductory 4.3BSD
Interprocess Communication Tutorial
D 3
.ps 10
E 3
I 3
.sz 10
E 3
.sp 2
E 2
.ce
D 2
Tutorial Examples of Interprocess Communication in Berkeley UNIX 4.3 BSD
.r
.sp2
.ce
E 2
.i "Stuart Sechrest"
I 2
.ft
E 2
.sp
D 2
.ce4
E 2
I 2
.ce 4
E 2
Computer Science Research Group
Computer Science Division
Department of Electrical Engineering and Computer Science
University of California, Berkeley
D 2
.sp2
E 2
I 2
.sp 2
E 2
.ce
.i ABSTRACT
.sp
.(c
D 2
.xl 5i
.lp
E 2
I 2
.pp
E 2
D 3
This is a second version of a tutorial document written for
Berkeley UNIX 4.2BSD.  The present version contains certain clarifications
and corrections.
D 2
.lp
E 2
I 2
.pp
E 2
Berkeley UNIX 4.3BSD offers several choices for interprocess communication.
E 3
I 3
Berkeley UNIX\(dg 4.3BSD offers several choices for interprocess communication.
E 3
D 4
To aid the programmer in  developing programs comprising cooperating
E 4
I 4
To aid the programmer in  developing programs which are comprised of
cooperating
E 4
processes, the different choices are discussed and a series of example 
programs are presented.  These programs
D 4
demonstrate in a simple way the use of pipes, socketpairs, and sockets
E 4
I 4
demonstrate in a simple way the use of pipes, socketpairs, sockets
E 4
and the use of datagram and stream communication.  The intent of this
document is to present a few simple example programs, not to describe the
D 4
networking system in full generality.
E 4
I 4
networking system in full.
E 4
D 2
.xl
E 2
.)c
D 2
.sp2
.ls2
E 2
I 2
.sp 2
E 2
.(f
D 3
UNIX is a trademark of AT&T Bell Laboratories.
E 3
I 3
\(dg\|UNIX is a trademark of AT&T Bell Laboratories.
E 3
D 2
.sp
This work was sponsored by the Defense Advanced Research Projects Agency
(DoD), ARPA Order No. 4031, monitored by the Naval Electronics Systems
Command under contract No. N00039-C-0235. 
The views and conclusions contained in this document are those of the
author and should not be interpreted as representing official policies,
either expressed or implied, of the Defense Research Projects Agency
or of the US Government.
E 2
.)f
.b
.sh 1 "Goals"
.r
.pp
D 5
UNIX is an operating system that supports processes.  Processes
sit in their own little worlds off on their own machines and generally
just compute. 
Occasionally it has been reasonable to 
write programs as small modular pieces that
talk to each other, since the resulting facilities can be flexible and
easy to modify.
More recently, with more computers sitting around in the same buildings
people have had the idea that
it would be nice if a process on one machine could talk to a process
on another machine.  For example these processes might relay commands
typed by the user across machine boundaries, allowing the user to
log into a different computer without walking to a new terminal,
rewiring the old terminal, or taking other time consuming actions.  
These ideas have been integrated and abstracted yielding an interface
for interprocess communication, or IPC.
.pp
E 5
I 5
Facilities for interprocess communication (IPC) and networking
were a major addition to UNIX in the Berkeley UNIX 4.2BSD release.
These facilities required major additions and some changes
to the system interface.
E 5
The basic idea of this interface is to make IPC similar to file I/O.
D 3
In UNIX a process has a set of I/O descriptors, which one reads from
and writes to.  The use of a descriptor has three phases, its creation,
E 3
I 3
In UNIX a process has a set of I/O descriptors, from which one reads
and to which one writes.
I 5
Descriptors may refer to normal files, to devices (including terminals),
or to communication channels.
E 5
The use of a descriptor has three phases: its creation,
E 3
its use for reading and writing, and its destruction.  By using descriptors
to write files, rather than simply naming the target file in the write
D 4
call, one gains a surprising amount of flexibility.  Often the program that
E 4
I 4
call, one gains a surprising amount of flexibility.  Often, the program that
E 4
creates a descriptor will be different from the program that uses the
descriptor.  For example the shell can create a descriptor for the output 
of the `ls'
command that will cause the listing to appear in a file rather than
D 3
on a terminal.  The use of descriptors is not uniform throughout UNIX.
E 3
I 3
D 5
on a terminal.  The use of descriptors is not the only communication mechanism
E 5
I 5
on a terminal.
Pipes are another form of descriptor that have been used in UNIX
for some time.
Pipes allow one-way data transmission from one process
to another; the two processes and the pipe must be set up by a common
ancestor.
.pp
The use of descriptors is not the only communication interface
E 5
provided by UNIX.
E 3
D 4
There is another mechanism to flash a tiny amount of information from one 
E 4
I 4
D 5
There is another mechanism which flashes a tiny amount of information from one 
E 4
process to another, telling it, for example, that someone wants it to stop.  
This is called sending a signal.  To signal
D 4
another process one states explicitly the identity of the recipient.
E 4
I 4
another process, one states explicitly the identity of the recipient.
E 4
This requirement limits the flexibility of the signaling mechanism
E 5
I 5
The signal mechanism sends a tiny amount of information from one 
process to another.
The signaled process receives only the signal type,
not the identity of the sender,
and the number of possible signals is small.
The signal semantics limit the flexibility of the signaling mechanism
E 5
as a means of interprocess communication.
.pp
The identification of IPC with I/O is quite longstanding in UNIX and
has proved quite successful.  At first, however, IPC was limited to
processes communicating within a single machine.  With Berkeley UNIX
4.2BSD this expanded to include IPC between machines.  This expansion
has necessitated some change in the way that descriptors are created.
Additionally, new possibilities for the meaning of read and write have
been admitted.  Originally the meanings, or semantics, of these terms
were fairly simple.  When you wrote something it was delivered.  When
D 4
you read, you blocked until the data arrived.  Other possibilities exist,
E 4
I 4
you read something, you were blocked until the data arrived.
Other possibilities exist,
E 4
however.  One can write without full assurance of delivery if one can
check later to catch occasional failures.  Messages can be kept as
discrete units or merged into a stream. 
One can ask to read, but insist on not waiting if nothing is immediately
available.  These new possibilities are allowed in the Berkeley UNIX IPC
interface.  
.pp
Thus Berkeley UNIX 4.3BSD offers several choices for IPC.
This paper presents simple examples that illustrate some of
the choices.
The reader is presumed to be familiar with the C programming language
[Kernighan & Ritchie 1978],
but not necessarily with the system calls of the UNIX system or with
processes and interprocess communication.
The paper reviews the notion of a process and the types of
communication that are supported by Berkeley UNIX 4.3BSD.
A series of examples are presented that create processes that communicate
with one another.  The programs show different ways of establishing
channels of communication.
Finally, the calls that actually transfer data are reviewed.
To clearly present how communication can take place,
the example programs have been cleared of anything that
might be construed as useful work.
They can, therefore, serve as models
D 4
for the programmer trying to construct programs comprising
E 4
I 4
for the programmer trying to construct programs which are comprised of 
E 4
cooperating processes.
.b
.sh 1 "Processes"
.pp
A \fIprogram\fP is both a sequence of statements and a rough way of referring 
to the computation that occurs when the compiled statements are run.
A \fIprocess\fP can be thought of as a single line of control in a program.
Most programs execute some statements, go through a few loops, branch in
D 4
various directions and then end.  They are single process programs.
E 4
I 4
various directions and then end.  These are single process programs.
E 4
Programs can also have a point where control splits into two independent lines,
an action called \fIforking.\fP
In UNIX these lines can never join again.  A call to the system routine 
D 4
\fIfork()\fP causes a process to split in this way.
E 4
I 4
\fIfork()\fP, causes a process to split in this way.
E 4
The result of this call is that two independent processes will be
running, executing exactly the same code.
Memory values will be the same for all values set before the fork, but,
subsequently, each version will be able to change only the 
value of its own copy of each variable.
Initially, the only difference between the two will be the value returned by
\fIfork().\fP  The parent will receive a process id for the child, 
the child will receive a zero.
Calls to \fIfork(),\fP
therefore, typically precede, or are included in, an if-statement.
.pp
A process views the rest of the system through a private table of descriptors.
The descriptors can represent open files or sockets (sockets are communication
objects that will be discussed below).  Descriptors are referred to
D 3
by their index numbers in the table.  The first three descriptors have been
given special names, \fI stdin, stdout\fP and \fIstderr.\fP
E 3
I 3
by their index numbers in the table.  The first three descriptors are often
known by special names, \fI stdin, stdout\fP and \fIstderr\fP.
E 3
These are the standard input, output and error.
When a process forks, its descriptor table is copied to the child.
Thus, if the parent's standard input is being taken from a terminal
(devices are also treated as files in UNIX), the child's input will 
be taken from the
same terminal.  Whoever reads first will get the input.  If, before forking,
the parent changes its standard input so that it is reading from a
new file, the child will take its input from the new file.  It is
also possible to take input from a socket, rather than from a file.
.b
.sh 1 "Pipes"
.r
.pp
Most users of UNIX know that they can pipe the output of a 
program ``prog1'' to the input of another, ``prog2,'' by typing the command
\fI``prog1 | prog2.''\fP
This is called ``piping'' the output of one program
to another because the mechanism used to transfer the output is called a
pipe.
When the user types a command, the command is read by the shell, which
D 3
decides how to execute it.  If the command is simple, say just
E 3
I 3
D 4
decides how to execute it.  If the command is simple, for example
E 4
I 4
decides how to execute it.  If the command is simple, for example,
E 4
E 3
.i "``prog1,''"
D 4
the shell forks a process, which executes the program prog1 and then dies.
E 4
I 4
the shell forks a process, which executes the program, prog1, and then dies.
E 4
The shell waits for this termination and then prompts for the next
command.
D 3
If the command is a compound command, say 
E 3
I 3
If the command is a compound command,
E 3
.i "``prog1 | prog2,''"
the shell creates two processes connected by a pipe. One process
D 4
runs the program prog1, the other runs prog2.  The pipe is an I/O
E 4
I 4
runs the program, prog1, the other runs prog2.  The pipe is an I/O
E 4
mechanism with two ends, or sockets.  Data that is written into one socket
can be read from the other.  
I 2
.(z
.ft CW
.so pipe.c
.ft
.ce 1
Figure 1\ \ Use of a pipe
.)z
E 2
.pp
Since a program specifies its input and output only by the descriptor table
indices, which appear as variables or constants,
the input source and output destination can be changed without
changing the text of the program.
It is in this way that the shell is able to set up pipes.  Before executing
prog1, the process can close whatever is at \fIstdout\fP
and replace it with one
end of a pipe.  Similarly, the process that will execute prog2 can substitute
the opposite end of the pipe for 
\fIstdin.\fP
D 2
.(z
.ft CW
.eo
.so ../examples/pipe.c
.ec \
.r
.ce 1
Figure 1\ \ Use of a pipe
.)z
E 2
.pp
Let us now examine a program that creates a pipe for communication between
its child and itself (Figure 1).
A pipe is created by a parent process, which then forks.
When a process forks, the parent's descriptor table is copied into 
the child's.  
.pp
In Figure 1, the parent process makes a call to the system routine 
\fIpipe().\fP
This routine creates a pipe and places descriptors for the sockets
for the two ends of the pipe in the process's descriptor table.
D 3
\fIPipe().\fP
E 3
I 3
\fIPipe()\fP
E 3
is passed an array into which it places the index numbers of the 
sockets it created.
The two ends are not equivalent.  The socket whose index is
returned in the low word of the array is opened for reading only,
while the socket in the high end is opened only for writing.
This corresponds to the fact that the standard input is the first
descriptor of a process's descriptor table and the standard output
D 4
the second.  After creating the pipe, the parent creates the child 
E 4
I 4
is the second.  After creating the pipe, the parent creates the child 
E 4
with which it will share the pipe by calling \fIfork().\fP
Figure 2 illustrates the effect of a fork.
The parent process's descriptor table points to both ends of the pipe.
D 4
After the fork, both parent's and child's descriptor table point to
E 4
I 4
After the fork, both parent's and child's descriptor tables point to
E 4
the pipe.
The child can then use the pipe to send a message to the parent.
.(z
D 2
.GS C
height 6i
file pipe
.GE
E 2
I 2
-
.bl 5.8i
-
.\" pipe.grn goes here
.sp
E 2
.ce 1
Figure 2\ \ Sharing a pipe between parent and child
.)z
.pp
Just what is a pipe?
It is a one-way communication mechanism, with one end opened
for reading and the other end for writing.
Therefore, parent and child need to agree on which way to turn
the pipe, from parent to child or the other way around.
Using the same pipe for communication both from parent to child and 
from child to parent would be possible (since both processes have 
references to both ends), but very complicated.
If the parent and child are to have a two-way conversation,
the parent creates two pipes, one for use in each direction.
D 4
(In accordance with their plans both parent and child in the example above
E 4
I 4
(In accordance with their plans, both parent and child in the example above
E 4
close the socket that they will not use.  It is not required that unused
descriptors be closed, but it is good practice.)
D 4
A pipe is also a \fIstream\fP communication mechanism, that
is all messages sent through the pipe are placed in order
D 3
and delivered.  When the reader asks for some number of bytes of this
E 3
I 3
and reliably delivered.  When the reader asks for some number of bytes of this
E 4
I 4
A pipe is also a \fIstream\fP communication mechanism; that
is, all messages sent through the pipe are placed in order
and reliably delivered.  When the reader asks for a certain
number of bytes from this
E 4
E 3
stream, he is given as many bytes as are available, up
D 4
to the amount of the request.  Note that this pays no attention
to whether those bytes all came from the same call to \fIwrite()\fP
or came from several calls to \fIwrite()\fP but were concatenated.
E 4
I 4
to the amount of the request. Note that these bytes may have come from 
the same call to \fIwrite()\fR or from several calls to \fIwrite()\fR
which were concatenated.
E 4
.b
.sh 1 "Socketpairs"
.r
.pp
D 3
Berkeley UNIX 4.2BSD provides a slight generalization of pipes.  A pipe is a
pair of connected sockets for one-way stream communication.  One can
get a pair of connected sockets for two-way stream communication
E 3
I 3
Berkeley UNIX 4.3BSD provides a slight generalization of pipes.  A pipe is a
pair of connected sockets for one-way stream communication.  One may
obtain a pair of connected sockets for two-way stream communication
E 3
by calling the routine \fIsocketpair().\fP
The program in Figure 3 calls \fIsocketpair()\fP
to create such a connection.  The program uses the link for
communication in both directions.  Since socketpairs are
an extension of pipes, their use resembles that of pipes. 
Figure 4 illustrates the result of a fork following a call to 
\fIsocketpair().\fP
.pp
\fISocketpair()\fP
takes as
arguments a specification of a domain, a style of communication, and a
protocol.  
These are the parameters shown in the example.
Domains and protocols will be discussed in the next section.
Briefly,
a domain is a space of names that may be bound
to sockets and implies certain other conventions.
Currently, socketpairs have only been implemented for one
domain, called the UNIX domain.
The UNIX domain uses UNIX path names for naming sockets.  
It only allows communication
between sockets on the same machine.
D 4
A style of communication is a statement about the semantics that
D 3
are desired.  Currently socketpairs can only act as streams.
E 3
I 3
are desired.
E 4
E 3
.pp
Note that the header files 
.i "<sys/socket.h>"
and
.i "<sys/types.h>."
are required in this program.
The constants AF_UNIX and SOCK_STREAM are defined in 
.i "<sys/socket.h>,"
which in turn requires the file 
.i "<sys/types.h>"
for some of its definitions.
.(z
.ft CW
D 2
.eo
.so ../examples/socketpair.c
.ec \
.r
E 2
I 2
.so socketpair.c
.ft
E 2
.ce 1
Figure 3\ \ Use of a socketpair
.)z
.(z
D 2
.GS C
height 6i
file socketpair
.GE
E 2
I 2
-
.bl 5.8i
-
.\" socketpair.grn goes here
.sp
E 2
.ce 1
Figure 4\ \ Sharing a socketpair between parent and child
.)z
.b
.sh 1 "Domains and Protocols"
.r
.pp
Pipes and socketpairs are a simple solution for communicating between
a parent and child or between child processes.
What if we wanted to have processes that have no common ancestor
D 4
to communicate?  Neither standard UNIX pipes nor socketpairs are
E 4
I 4
with whom to set up communication?
Neither standard UNIX pipes nor socketpairs are
E 4
the answer here, since both mechanisms require a common ancestor to
set up the communication.
We would like to have two processes separately create sockets
and then have messages sent between them.  This is often the
case when providing or using a service in the system.  This is
also the case when the communicating processes are on separate machines.
In Berkeley UNIX 4.3BSD one can create individual sockets, give them names and
send messages between them.
.pp
D 3
Sockets created by different programs use names to refer to one another.
The space from which a name is drawn is referred to as a
E 3
I 3
Sockets created by different programs use names to refer to one another;
names generally must be translated into addresses for use.
The space from which an address is drawn is referred to as a
E 3
.i domain.
D 3
There are currently two domains for sockets, the UNIX domain (or AF_UNIX,
E 3
I 3
There are several domains for sockets.
Two that will be used in the examples here are the UNIX domain (or AF_UNIX,
E 3
for Address Format UNIX) and the Internet domain (or AF_INET).
I 3
UNIX domain IPC is an experimental facility in 4.2BSD and 4.3BSD.
E 3
In the UNIX domain, a socket is given a path name within the file system
name space.
A file system node is created for the socket and other processes may 
then refer to the socket by giving the proper pathname.
D 3
Names in the internet domain consist of a machine network address
and an identifying number, called a port.
E 3
UNIX domain names, therefore, allow communication between any two processes
that work in the same file system.
I 3
The Internet domain is the UNIX implementation of the DARPA Internet
standard protocols IP/TCP/UDP.
Addresses in the Internet domain consist of a machine network address
and an identifying number, called a port.
E 3
Internet domain names allow communication between machines.
.pp
Communication follows some particular ``style.''
Currently, communication is either through a \fIstream\fP
or by \fIdatagram.\fP
Stream communication implies several things.  Communication takes
place across a connection between two sockets.  The communication
is reliable, error-free, and, as in pipes, no message boundaries are
kept. Reading from a stream may result in reading the data sent from
one or several calls to \fIwrite()\fP
or only part of the data from a single call, if there is not enough room
for the entire message, or if not all the data from a large message
has been transferred.
The protocol implementing such a style will retransmit messages
received with errors. It will also return error messages if one tries to
send a message after the connection has been broken.
Datagram communication does not use connections.  Each message is
addressed individually.  If the address is correct, it will generally
be received, although this is not guaranteed.  Often datagrams are
used for requests that require a response from the 
recipient.  If no response
arrives in a reasonable amount of time, the request is repeated.
The individual datagrams will be kept separate when they are read, that
is, message boundaries are preserved.
.pp
The difference in performance between the two styles of communication is 
generally less important than the difference in semantics.  The
performance gain that one might find in using datagrams must be weighed
against the increased complexity of the program, which must now concern
itself with lost or out of order messages.  If lost messages may simply be 
D 4
ignored, the quantity of traffic may be a consideration; the expense
E 4
I 4
ignored, the quantity of traffic may be a consideration. The expense
E 4
of setting up a connection is best justified by frequent use of the connection.
Since the performance of a protocol changes as it is tuned for different
situations, it is best to seek the most up-to-date information when
making choices for a program in which performance is crucial.
.pp
D 3
A protocol is a set of rules and conventions that regulate the
E 3
I 3
A protocol is a set of rules, data formats and conventions that regulate the
E 3
transfer of data between participants in the communication.
I 3
In general, there is one protocol for each socket type (stream,
datagram, etc.) within each domain.
E 3
The code that implements a protocol 
keeps track of the names that are bound to sockets,
sets up connections and	transfers data between sockets,
perhaps sending the data across a network.
This code also keeps track of the names that are bound to sockets.
It is possible for several protocols, differing only in low level
details, to implement the same style of communication within
a particular domain.  Although it is possible to select
D 3
which protocol should be used, for most users it is simplest to 
E 3
I 3
which protocol should be used, for nearly all uses it is sufficient to
E 3
D 4
request the default protocol.  This has been done in all the example
E 4
I 4
request the default protocol.  This has been done in all of the example
E 4
programs.
.pp
One specifies the domain, style and protocol of a socket when
it is created.  For example, in Figure 5a the call to \fIsocket()\fP
causes the creation of a datagram socket with the default protocol 
in the UNIX domain.
.b
.sh 1 "Datagrams in the UNIX Domain"
.r
I 2
.(z
.ft CW
.so udgramread.c
.ft
.ce 1
D 4
Figure 5a\ \ Reading using UNIX domain datagrams
E 4
I 4
Figure 5a\ \ Reading UNIX domain datagrams
E 4
.)z
E 2
.pp
Let us now look at two programs that create sockets separately.
The programs in Figures 5a and 5b use datagram communication
rather than a stream.  
The structure used to name UNIX domain sockets is defined
in the file \fI<sys/un.h>.\fP
The definition has also been included in the example for clarity.
.pp
Each program creates a socket with a call to \fIsocket().\fP
These sockets are in the UNIX domain.
Once a name has been decided upon it is attached to a socket by the
system call \fIbind().\fP
The program in Figure 5a uses the name ``socket'',
which it binds to its socket.
D 3
This name will appear in the working directory of the person running
the program.
E 3
I 3
This name will appear in the working directory of the program.
E 3
D 4
The routines in Figure 5b uses its
E 4
I 4
The routines in Figure 5b use its
E 4
socket only for sending messages.  It does not create a name for
the socket because no other process has to refer to it.  
.(z
.ft CW
D 2
.eo
.so ../examples/udgramread.c
.ec \
.r
.sp 1
E 2
I 2
.so udgramsend.c
.ft
E 2
.ce 1
D 2
Figure 5a\ \ Reading using UNIX domain datagrams
.)z
.(z
.ft CW
.eo
.so ../examples/udgramsend.c
.ec \
.r
.sp 1
.ce 1
E 2
Figure 5b\ \ Sending a UNIX domain datagrams
.)z
.pp
Names in the UNIX domain are path names.  Like file path names they may
be either absolute (e.g. ``/dev/imaginary'') or relative (e.g. ``socket'').
Because these names are used to allow processes to rendezvous, relative
path names can pose difficulties and should be used with care.
D 3
When a name is bound into the name space, an i-node is allocated in the
E 3
I 3
When a name is bound into the name space, a file (inode) is allocated in the
E 3
file system.  If
D 3
the i-node is not deallocated, the name will continue to exist even after
E 3
I 3
the inode is not deallocated, the name will continue to exist even after
E 3
the bound socket is closed.  This can cause subsequent runs of a program
D 4
to find that a name is unavailable, and directories to fill up with these
E 4
I 4
to find that a name is unavailable, and can cause 
directories to fill up with these
E 4
D 3
objects.  The names are removed by calling \fIunlink().\fP
E 3
I 3
objects.  The names are removed by calling \fIunlink()\fP or using
the \fIrm\fP\|(1) command.
E 3
Names in the UNIX domain are only used for rendezvous.  They are not used
for message delivery once a connection is established.  Therefore, in
D 3
contrast with the Internet domain, unnamed sockets need not be (and are
not) automatically given names when they are connected.  
E 3
I 3
contrast with the Internet domain, unbound sockets need not be (and are
not) automatically given addresses when they are connected.  
E 3
.pp
There is no established means of communicating names to interested
parties.  In the example, the program in Figure 5b gets the
name of the socket to which it will send its message through its
D 4
command line arguments.  Once a line of communication has been created
E 4
I 4
command line arguments.  Once a line of communication has been created,
E 4
one can send the names of additional, perhaps new, sockets over the link.
Facilities will have to be built that will make the distribution of
names less of a problem than it now is.
.b
.sh 1 "Datagrams in the Internet Domain"
.r
I 2
.(z
.ft CW
.so dgramread.c
.ft
.ce 1
D 4
Figure 6a\ \ Reading using Internet domain datagrams
E 4
I 4
Figure 6a\ \ Reading Internet domain datagrams
E 4
.)z
E 2
.pp
The examples in Figure 6a and 6b are very close to the previous example
except that the socket is in the Internet domain.
D 3
The structure of internet domain names is defined in the file
\fI<netinet/in.h>.\fP
Internet domain names specify a delivery slot, or port, on a particular
machine.  These names are managed by the system routines that implement 
E 3
I 3
The structure of Internet domain addresses is defined in the file
\fI<netinet/in.h>\fP.
Internet addresses specify a host address (a 32-bit number)
and a delivery slot, or port, on that
machine.  These ports are managed by the system routines that implement 
E 3
a particular protocol.
D 3
Unlike UNIX domain names, Internet domain names are not entered into 
E 3
I 3
Unlike UNIX domain names, Internet socket names are not entered into 
E 3
the file system and, therefore,
D 3
they do not have to be unlinked after the named socket has been closed.
Routines implementing a particular protocol can run on several different
machines.  When a message must be sent between machines it is sent to
E 3
I 3
they do not have to be unlinked after the socket has been closed.
When a message must be sent between machines it is sent to
E 3
the protocol routine on the destination machine, which interprets the
D 3
Internet name to decide to which socket the message should be delivered.
E 3
I 3
address to determine to which socket the message should be delivered.
E 3
Several different protocols may be active on 
D 3
the same machine, but, in general, they will not talk to one another.
As a result, different protocols are allowed to use the same name, that is a 
particular \fI<port, machine address>\fP
pair, to indicate a socket using that protocol.
Thus, implicitly, an Internet name is a triple including a protocol as
E 3
I 3
the same machine, but, in general, they will not communicate with one another.
As a result, different protocols are allowed to use the same port numbers.
Thus, implicitly, an Internet address is a triple including a protocol as
E 3
well as the port and machine address.
I 3
An \fIassociation\fP is a temporary or permanent specification
of a pair of communicating sockets.
An association is thus identified by the tuple
<\fIprotocol, local machine address, local port,
remote machine address, remote port\fP>.
D 4
An association may transient when using datagram sockets;
E 4
I 4
An association may be transient when using datagram sockets;
E 4
the association actually exists during a \fIsend\fP operation.
E 3
.(z
.ft CW
D 2
.eo
.so ../examples/dgramread.c
.ec \
.r
.sp 1
E 2
I 2
.so dgramsend.c
.ft
E 2
.ce 1
D 2
Figure 6a\ \ Reading using Internet domain datagrams
.)z
.(z
.ft CW
.eo
.so ../examples/dgramsend.c
.ec \
.r
.sp 1
.ce 1
E 2
Figure 6b\ \ Sending an Internet domain datagram
.)z
.pp
The protocol for a socket is chosen when the socket is created.  The 
D 3
machine address for a socket can be any valid network address of the
E 3
I 3
local machine address for a socket can be any valid network address of the
E 3
machine, if it has more than one, or it can be the wildcard value
INADDR_ANY.
The wildcard value is used in the program in Figure 6a.
If a machine has several network addresses, it is likely
that messages sent to any of the addresses should be deliverable to
a socket.  This will be the case if the wildcard value has been chosen.
Note that even if the wildcard value is chosen, a program sending messages
D 3
to the
named socket must specify a valid network address.  One can be willing
E 3
I 3
to the named socket must specify a valid network address.  One can be willing
E 3
to receive from ``anywhere,'' but one cannot send a message ``anywhere.''
The program in Figure 6b is given the destination host name as a command
line argument.
To determine a network address to which it can send the message, it looks
D 3
the host address up by the call to \fIgethostbyname().\fP
E 3
I 3
D 4
the host address up by the call to \fIgethostbyname()\fP.
E 4
I 4
up
the host address by the call to \fIgethostbyname()\fP.
E 4
E 3
The returned structure includes the host's network address,
which is copied into the structure specifying the
destination of the message.
.pp
The port number can be thought of as the number of a mailbox, into
D 3
which the protocol places ones messages.  Certain daemons, offering
E 3
I 3
which the protocol places one's messages.  Certain daemons, offering
E 3
certain advertised services, have reserved
D 3
mailboxes with ``well-known'' port numbers.  These fall in the range
from 1 to 1023.  Higher numbers are available to general users.  One does not
typically ask for a particular number, since this would lead to collisions.
Instead one specifies the port number 0, which causes a free port number
to be assigned to the socket.  Since Internet names are necessary for
message delivery in the Internet domain, names are bound to unnamed 
sockets during a connect.
Note that names are not automatically reported back to the user.  After
calling \fIbind(),\fP asking for port 0, one can call 
E 3
I 3
or ``well-known'' port numbers.  These fall in the range
from 1 to 1023.  Higher numbers are available to general users.
Only servers need to ask for a particular number.
The system will assign an unused port number when an address
is bound to a socket.
This may happen when an explicit \fIbind\fP
call is made with a port number of 0, or
when a \fIconnect\fP or \fIsend\fP
is performed on an unbound socket.
Note that port numbers are not automatically reported back to the user.
After calling \fIbind(),\fP asking for port 0, one may call 
E 3
\fIgetsockname()\fP to discover what port was actually assigned. 
The routine \fIgetsockname()\fP
will not work for names in the UNIX domain.
.pp
D 3
The format of the socket name is specified in the design of the
E 3
I 3
The format of the socket address is specified in part by standards within the
E 3
Internet domain.  The specification includes the order of the bytes in
D 3
the name.  Because machines differ in the order they ordinarily use
E 3
I 3
the address.  Because machines differ in the internal representation
they ordinarily use
E 3
to represent integers, printing out the port number as returned by 
\fIgetsockname()\fP may result in a misinterpretation.  To
D 3
print out the number, it is necessary to use the macro \fIntohs()\fP
E 3
I 3
print out the number, it is necessary to use the routine \fIntohs()\fP
E 3
(for \fInetwork to host: short\fP) to convert the number from the
network representation to the host's representation.  On some machines,
such as 68000-based machines, this is a null operation.  On others,
D 3
such as VAXes, this results in a swapping of bytes.  A similar macro
exists to convert a short integer from the host format to the network format.
This is called \fIhtons().\fP  For further information, refer to the
E 3
I 3
such as VAXes, this results in a swapping of bytes.  Another routine
exists to convert a short integer from the host format to the network format,
called \fIhtons()\fP; similar routines exist for long integers.
For further information, refer to the
E 3
entry for \fIbyteorder\fP in section 3 of the manual.
.b
.sh 1 "Connections"
.r
.pp
To send data between stream sockets (having communication style SOCK_STREAM),
the sockets must be connected.
D 2
Figures 7a and 7b show two programs that create such a connection.  The program in
7b is relatively simple.  To initiate a connection, this program
simply calls \fI connect(), \fP
E 2
I 2
Figures 7a and 7b show two programs that create such a connection.
The program in 7a is relatively simple.
D 3
To initiate a connection, this program simply calls \fI connect(), \fP
E 2
specifying the name of the socket to which
E 3
I 3
To initiate a connection, this program simply creates
a stream socket, then calls \fIconnect()\fP,
specifying the address of the socket to which
E 3
it wishes its socket connected.  Provided that the target socket exists and
D 3
is prepared to handle a connection, the program can begin to send
E 3
I 3
D 4
is prepared to handle a connection, connection will complete,
E 4
I 4
is prepared to handle a connection, connection will be complete,
E 4
and the program can begin to send
E 3
messages.  Messages will be delivered in order without message
boundaries, as with pipes.  The connection is destroyed when either
D 3
end socket is closed (or soon thereafter).  If the process persists 
E 3
I 3
socket is closed (or soon thereafter).  If a process persists 
E 3
in sending messages after the connection is closed, a SIGPIPE signal 
is sent to the process by the operating system.  Unless explicit action
is taken to handle the signal (see the manual page for \fIsignal\fP
or \fIsigvec\fP),
the process will terminate and the shell
will print the message ``broken pipe.'' 
.(z
.ft CW
D 2
.eo
.so ../examples/streamread.c
.ec \
.r
.sp 1
E 2
I 2
.so streamwrite.c
.ft
E 2
.ce 1
D 2
Figure 7a\ \ Accepting an Internet domain stream connection
E 2
I 2
Figure 7a\ \ Initiating an Internet domain stream connection
E 2
.)z
.(z
.ft CW
D 2
.eo
.so ../examples/streamwrite.c
.ec \
.r
.sp 1
E 2
I 2
.so streamread.c
.ft
E 2
.ce 1
D 2
Figure 7b\ \ Initiating an Internet domain stream connection
.)z
.(z
E 2
I 2
Figure 7b\ \ Accepting an Internet domain stream connection
.sp 2
E 2
.ft CW
D 2
.eo
.so ../examples/strchkread.c
.ec \
.r
.sp 1
E 2
I 2
.so strchkread.c
.ft
E 2
.ce 1
Figure 7c\ \ Using select() to check for pending connections
.)z
.(z
D 2
.GS C
height 6i
file accept
.GE
E 2
I 2
-
.bl 5.8i
-
.\" accept.grn goes here
.sp
E 2
.ce 1
Figure 8\ \ Establishing a stream connection
.)z
.pp
D 3
Forming a connection is asymmetrical; one process, like that running the
E 3
I 3
Forming a connection is asymmetrical; one process, such as the
E 3
D 2
program in Figure 7b, requests a connection with a particular socket,
E 2
I 2
program in Figure 7a, requests a connection with a particular socket,
E 2
the other process accepts connection requests.
D 3
Before a connection can be accepted a socket must be created and a name 
E 3
I 3
Before a connection can be accepted a socket must be created and an address
E 3
bound to it.  This
situation is illustrated in the top half of Figure 8.  Process 2
D 3
has created a socket and bound a name to it.  Process 1 has created an
E 3
I 3
has created a socket and bound a port number to it.  Process 1 has created an
E 3
unnamed socket.
D 3
The name bound to process 2's socket is then made known to process 1 and, 
E 3
I 3
The address bound to process 2's socket is then made known to process 1 and, 
E 3
perhaps to several other potential communicants as well.
If there are several possible communicants,
D 3
this one socket might get several requests for connections.
E 3
I 3
this one socket might receive several requests for connections.
E 3
As a result, a new socket is created for each connection.  This new socket
D 3
is the endpoint of communication within this process for this connection.
A connection can be destroyed by closing the corresponding socket.
E 3
I 3
is the endpoint for communication within this process for this connection.
A connection may be destroyed by closing the corresponding socket.
E 3
.pp
D 2
The program in Figure 7a is a rather trivial example of a server.  It 
E 2
I 2
The program in Figure 7b is a rather trivial example of a server.  It 
E 2
creates a socket to which it binds a name, which it then advertises.
(In this case it prints out the socket number.)  The program then calls
D 3
\fIlisten() \fP for this socket.  
E 3
I 3
\fIlisten()\fP for this socket.  
E 3
Since several clients may attempt to connect more or less
simultaneously, a queue of pending connections is maintained in the system
address space.  \fIListen()\fP
D 3
prepares the socket to accept connections by initializing the queue.
E 3
I 3
marks the socket as willing to accept connections and initializes the queue.
E 3
When a connection is requested, it is listed in the queue.  If the
D 3
queue is full, an error status is returned to the requester.
E 3
I 3
queue is full, an error status may be returned to the requester.
E 3
The maximum length of this queue is specified by the second argument of
D 3
\fIlisten()\fP (the maximum length may be limited by the system).  
E 3
I 3
\fIlisten()\fP; the maximum length is limited by the system.  
E 3
Once the listen call has been completed, the program enters
an infinite loop.  On each pass through the loop, a new connection is
accepted and removed from the queue, and, hence, a new socket for the 
connection is created.  The bottom half of Figure 8 shows the result of
D 4
Process 1 connecting with the named socket of Process 2 and Process 2
E 4
I 4
Process 1 connecting with the named socket of Process 2, and Process 2
E 4
accepting the connection.  After the connection is created, the
service, in this case printing out the messages, is performed and the
connection socket closed.  The \fIaccept()\fP
call will take a pending connection
D 3
request from the queue, if one is available, or block, waiting for a request.
E 3
I 3
request from the queue if one is available, or block waiting for a request.
E 3
Messages are read from the connection socket.
Reads from an active connection will normally block until data is available.
The number of bytes read is returned.  When a connection is destroyed,
the read call returns immediately.  The number of bytes returned will
be zero.
.pp
D 2
The program in Figure 7c is a slight variation on the server in Figure 7a.
E 2
I 2
The program in Figure 7c is a slight variation on the server in Figure 7b.
E 2
It avoids blocking when there are no pending connection requests by 
D 3
calling \fIselect() \fP
E 3
I 3
calling \fIselect()\fP
E 3
to check for pending requests before calling \fIaccept().\fP
I 3
This strategy is useful when connections may be received
on more than one socket, or when data may arrive on other connected
sockets before another connection request.
E 3
.pp
The programs in Figures 9a and 9b show a program using stream communication
in the UNIX domain.  Streams in the UNIX domain can be used for this sort
of program in exactly the same way as Internet domain streams, except for
the form of the names and the restriction of the connections to a single
file system.  There are some differences, however, in the functionality of 
streams in the two domains, notably in the handling of 
D 3
\fIout-of-band \fP data (discussed briefly below).  These differences
E 3
I 3
\fIout-of-band\fP data (discussed briefly below).  These differences
E 3
are beyond the scope of this paper.
.(z
.ft CW
D 2
.eo
.so ../examples/ustreamread.c
.ec \
.r
.sp 1
E 2
I 2
.so ustreamwrite.c
.ft
E 2
.ce 1
D 2
Figure 9a\ \ Accepting a UNIX domain stream connection
.)z
.(z
E 2
I 2
Figure 9a\ \ Initiating a UNIX domain stream connection
.sp 2
E 2
.ft CW
D 2
.eo
.so ../examples/ustreamwrite.c
.ec \
.r
.sp 1
E 2
I 2
.so ustreamread.c
.ft
E 2
.ce 1
D 2
Figure 9b\ \ Initiating a UNIX domain stream connection
E 2
I 2
Figure 9b\ \ Accepting a UNIX domain stream connection
E 2
.)z
.b
.sh 1 "Reads, Writes, Recvs, etc."
.r
.pp
D 3
UNIX 4.2 BSD has several system calls for reading and writing information.
E 3
I 3
UNIX 4.3BSD has several system calls for reading and writing information.
E 3
The simplest calls are \fIread() \fP and \fIwrite().\fP \fIWrite()\fP
takes as arguments the index of a descriptor, a pointer to a buffer 
containing the data and the size of the data.
The descriptor may indicate either a file or a connected socket.  
``Connected'' can mean either a connected stream socket (as described
in Section 8) or a datagram socket for which a \fIconnect()\fP
call has provided a default destination (see the \fIconnect()\fP manual page).
\fIRead()\fP also takes a descriptor that indicates either a file or a socket.
\fIWrite()\fP requires a connected socket since no destination is 
specified in the parameters of the system call.
\fIRead()\fP can be used for either a connected or an unconnected socket.
These calls are, therefore, quite flexible and may be used to
write applications that require no assumptions about the source of
their input or the destination of their output.
There are variations on \fIread() \fP and \fIwrite()\fP
D 3
that allow the source and destination of the input and output to be
E 3
I 3
that allow the source and destination of the input and output to use
E 3
several separate buffers, while retaining the flexibility to handle
both files and sockets.  These are \fIreadv()\fP and \fI writev(),\fP
for read and write \fIvector.\fP
.pp 
It is sometimes necessary to send high priority data over a
connection that may have unread low priority data at the
other end.  For example, a user interface process may be interpreting
commands and sending them on to another process through a stream connection.
The user interface may have filled the stream with as yet unprocessed 
requests when the user types
a command to cancel all outstanding requests.
Rather than have the high priority data wait
to be processed after the low priority data, it is possible to
D 3
send it as \fIout-of-band \fP
(OOB) data.  The reception of OOB data results in the generation of
E 3
I 3
send it as \fIout-of-band\fP
(OOB) data.  The notification of pending OOB data results in the generation of
E 3
a SIGURG signal, if this signal has been enabled (see the manual
page for \fIsignal\fP or \fIsigvec\fP).
D 3
See [Leffler 1983] for a more complete description of the OOB mechanism.
There are a pair of calls allowing the sending 
and receiving of OOB information.  These are \fI send()\fP
E 3
I 3
See [Leffler 1986] for a more complete description of the OOB mechanism.
There are a pair of calls similar to \fIread\fP and \fIwrite\fP
that allow options, including sending 
and receiving OOB information; these are \fI send()\fP
E 3
and \fIrecv().\fP
D 3
These calls require the use of sockets; specifying a file descriptor will
E 3
I 3
These calls are used only with sockets; specifying a descriptor for a file will
E 3
result in the return of an error status.  These calls also allow
\fIpeeking\fP at data in a stream.
D 3
That is they allow a process to read data without removing the data from
E 3
I 3
That is, they allow a process to read data without removing the data from
E 3
the stream.  One use of this facility is to read ahead in a stream
to determine the size of the next item to be read.
When not using these options, these calls have the same functions as 
D 3
\fI read()\fP and \fIwrite().\fP
E 3
I 3
\fIread()\fP and \fIwrite().\fP
E 3
.pp
To send datagrams, one must be allowed to specify the destination.
The call \fIsendto()\fP
D 3
takes as input a destination address and is therefore used for
E 3
I 3
takes a destination address as an argument and is therefore used for
E 3
sending datagrams.  The call \fIrecvfrom()\fP
D 3
is often used to read datagrams, since this call returns the name
of the sender, if it is available.
E 3
I 3
is often used to read datagrams, since this call returns the address
of the sender, if it is available, along with the data.
E 3
If the identity of the sender does not matter, one may use \fIread()\fP
or \fIrecv().\fP
.pp
Finally, there are a pair of calls that allow the sending and
D 3
receiving of messages from multiple buffers, when the name of the
E 3
I 3
receiving of messages from multiple buffers, when the address of the
E 3
recipient must be specified.  These are \fIsendmsg()\fP and 
\fIrecvmsg().\fP
These calls are actually quite general and have other uses,
D 3
including, in the UNIX domain, the handing of a socket from one
E 3
I 3
including, in the UNIX domain, the transmission of a file descriptor from one
E 3
process to another.
.pp
The various options for reading and writing are shown in Figure 10,
together with their parameters.  The parameters for each system call
reflect the differences in function of the different calls.
In the examples given in this paper, the calls \fIread()\fP and 
D 3
\fIwrite()\fP have been used whenever possible.  One can go along time
without having to use most of the other calls.
E 3
I 3
\fIwrite()\fP have been used whenever possible.
E 3
.(z
.ft CW
D 2
     cc	= read(descriptor, buf, nbytes)
     int cc, descriptor; char *buf; int nbytes;
     /* The variable descriptor may be the descriptor of either a file
      * or of a socket.
      */
E 2
I 2
	/*
	 * The variable descriptor may be the descriptor of either a file
	 * or of a socket.
	 */
	cc = read(descriptor, buf, nbytes)
	int cc, descriptor; char *buf; int nbytes;
E 2

D 2
     cc	= readv(descriptor, iov, iovcnt)
     int cc, descriptor; struct iovec *iov; int iovcnt;
     /* An iovec can include several source buffers.
      */
E 2
I 2
	/*
	 * An iovec can include several source buffers.
	 */
	cc = readv(descriptor, iov, iovcnt)
	int cc, descriptor; struct iovec *iov; int iovcnt;
E 2

D 2
     cc = write(descriptor, buf, nbytes)
     int cc, descriptor; char *buf; int nbytes;
E 2
I 2
	cc = write(descriptor, buf, nbytes)
	int cc, descriptor; char *buf; int nbytes;
E 2

D 2
     cc = writev(descriptor, iovec, ioveclen)
     int cc, descriptor; struct iovec *iovec; int ioveclen;
E 2
I 2
	cc = writev(descriptor, iovec, ioveclen)
	int cc, descriptor; struct iovec *iovec; int ioveclen;
E 2

D 2
     cc	= send(socket, msg, len, flags)
     int cc, socket; char *msg; int len, flags; 
     /* The variable socket must be the descriptor of a socket.
      * Flags include OOB and ``peeking.''
      */
E 2
I 2
	/*
D 3
	 * The variable socket must be the descriptor of a socket.
	 * Flags include OOB and ``peeking.''
E 3
I 3
	 * The variable ``sock'' must be the descriptor of a socket.
	 * Flags may include MSG_OOB and MSG_PEEK.
E 3
	 */
D 3
	cc = send(socket, msg, len, flags)
	int cc, socket; char *msg; int len, flags; 
E 3
I 3
	cc = send(sock, msg, len, flags)
	int cc, sock; char *msg; int len, flags; 
E 3
E 2

D 2
     cc	= sendto(socket, msg, len, flags, to, tolen)
     int cc, socket; char *msg; int len, flags; struct sockaddr *to; int tolen;
E 2
I 2
D 3
	cc = sendto(socket, msg, len, flags, to, tolen)
	int cc, socket; char *msg; int len, flags;
E 3
I 3
	cc = sendto(sock, msg, len, flags, to, tolen)
	int cc, sock; char *msg; int len, flags;
E 3
	struct sockaddr *to; int tolen;
E 2

D 2
     cc	= sendmsg(socket, msg, flags)
     int cc, socket; struct msghdr msg[]; int flags;
E 2
I 2
D 3
	cc = sendmsg(socket, msg, flags)
	int cc, socket; struct msghdr msg[]; int flags;
E 3
I 3
	cc = sendmsg(sock, msg, flags)
	int cc, sock; struct msghdr msg[]; int flags;
E 3
E 2

D 2
     cc	= recv(socket, buf, len, flags)
     int cc, socket; char *buf; int len, flags;
E 2
I 2
D 3
	cc = recv(socket, buf, len, flags)
	int cc, socket; char *buf; int len, flags;
E 3
I 3
	cc = recv(sock, buf, len, flags)
	int cc, sock; char *buf; int len, flags;
E 3
E 2

D 2
     cc	= recvfrom(socket, buf, len, flags, from, fromlen)
     int cc, socket; char *buf; int len, flags;
     struct sockaddr *from; int *fromlen;
E 2
I 2
D 3
	cc = recvfrom(socket, buf, len, flags, from, fromlen)
	int cc, socket; char *buf; int len, flags;
E 3
I 3
	cc = recvfrom(sock, buf, len, flags, from, fromlen)
	int cc, sock; char *buf; int len, flags;
E 3
	struct sockaddr *from; int *fromlen;
E 2

D 2
     cc	= recvmsg(socket, msg, flags)
     int cc, socket; struct msghdr msg[]; int flags;
.r
E 2
I 2
D 3
	cc = recvmsg(socket, msg, flags)
E 3
I 3
	cc = recvmsg(sock, msg, flags)
E 3
	int cc, socket; struct msghdr msg[]; int flags;
.ft
E 2
.sp 1
.ce 1
Figure 10\ \ Varieties of read and write commands
.)z
.b
.sh 1 "Choices"
.r
.pp
D 3
This paper has presented some of the forms of communication supported by
E 3
I 3
This paper has presented examples of some of the forms
of communication supported by
E 3
Berkeley UNIX 4.3BSD.  These have been presented in an order chosen for
ease of presentation.  It is useful to review these options emphasizing the
factors that make each attractive.
.pp
Pipes have the advantage of portability, in that they are supported in all
D 3
UNIX systems, not just the Berkeley system.  They also are relatively
E 3
I 3
UNIX systems.  They also are relatively
E 3
simple to use.  Socketpairs share this simplicity and have the additional
advantage of allowing bidirectional communication.  The major shortcoming
of these mechanisms is that they require communicating processes to be
descendants of a common process.  They do not allow intermachine communication.
.pp
D 3
The two naming domains, UNIX and Internet, allow processes with no common
ancestor to communicate.  Currently, only the Internet domain allows
communication between machines.  This makes the Internet domain a necessary
E 3
I 3
The two communication domains, UNIX and Internet, allow processes with no common
ancestor to communicate.
Of the two, only the Internet domain allows
communication between machines.
This makes the Internet domain a necessary
E 3
choice for processes running on separate machines.
.pp
The choice between datagrams and stream communication is best made by
carefully considering the semantic and performance
requirements of the application.
Streams can be both advantageous and disadvantageous.  One disadvantage
is that a process is only allowed a limited number of open streams,
D 3
since there are usually only twenty entries available in the open descriptor
E 3
I 3
as there are usually only 64 entries available in the open descriptor
E 3
table.  This can cause problems if a single server must talk with a large
number of clients. 
Another is that for delivering a short message the stream setup and 
D 4
teardown time can be unnecessarily large.  Weighed against this are
E 4
I 4
teardown time can be unnecessarily long.  Weighed against this are
E 4
the reliability built into the streams.  This will often be the
deciding factor in favor of streams.
.b
.sh 1 "What to do Next"
.r
.pp
Many of the examples presented here can serve as models for multiprocess
programs and for programs distributed across several machines.  
In developing a new multiprocess program, it is often easiest to 
first write the code to create the processes and communication paths.
After this code is debugged, the code specific to the application can
be added.
.pp
An introduction to the UNIX system and programming using UNIX system calls
can be found in [Kernighan and Pike 1984].
Further documentation of the Berkeley UNIX 4.3BSD IPC mechanisms can be 
D 3
found in [Leffler, Fabry & Joy 1983].
More detailed information about particular calls is provided by the
UNIX Programmer's Manual [Leffler, Joy & McKusick 1983].
E 3
I 3
found in [Leffler et al. 1986].
More detailed information about particular calls and protocols
is provided in sections
2, 3 and 4 of the
UNIX Programmer's Manual [CSRG 1986].
E 3
In particular the following manual pages are relevant:
D 2
.sp 1
.ti 5
creating and naming sockets:\ \ \ socket(2),
bind(2)
.sp 1
.ti 5
establishing connections:\ \ \ listen(2),
accept(2),
connect(2)
.sp 1
.ti 5
transferring data:\ \ \ read(2),
write(2),
send(2),
recv(2)
.sp 1
.ti 5
addresses:\ \ \ inet(4F)
.sp 1
.ti 5
protocols:\ \ \ tcp(4P),
udp(4P).
E 2
.(b
I 2
.TS
l l.
creating and naming sockets	socket(2), bind(2)
establishing connections	listen(2), accept(2), connect(2)
transferring data	read(2), write(2), send(2), recv(2)
addresses	inet(4F)
protocols	tcp(4P), udp(4P).
.TE
.)b
.(b
E 2
.sp
.b
Acknowledgements
.pp
I would like to thank Sam Leffler and Mike Karels for their help in
understanding the IPC mechanisms and all the people whose comments 
have helped in writing and improving this report.
I 2
.pp
This work was sponsored by the Defense Advanced Research Projects Agency
(DoD), ARPA Order No. 4031, monitored by the Naval Electronics Systems
Command under contract No. N00039-C-0235. 
The views and conclusions contained in this document are those of the
author and should not be interpreted as representing official policies,
either expressed or implied, of the Defense Research Projects Agency
or of the US Government.
E 2
.)b
.(b
.sp
.b
References
.r
.sp
.ls 1
B.W. Kernighan & R. Pike, 1984,
.i "The UNIX Programming Environment."
Englewood Cliffs, N.J.: Prentice-Hall.
.sp
.ls 1
B.W. Kernighan & D.M. Ritchie, 1978,
.i "The C Programming Language,"
Englewood Cliffs, N.J.: Prentice-Hall.
.sp
.ls 1
D 3
S.J. Leffler, R.S. Fabry & W.N. Joy, 1983,
.i "A 4.2BSD Interprocess Communication Primer."
E 3
I 3
S.J. Leffler, R.S. Fabry, W.N. Joy, P. Lapsley, S. Miller & C. Torek, 1986,
.i "An Advanced 4.3BSD Interprocess Communication Tutorial."
E 3
Computer Systems Research Group,
Department of Electrical Engineering and Computer Science,
University of California, Berkeley.
.sp
.ls 1
D 3
S.J.  Leffler, W.N. Joy & M.K. McKusick, 1983,
.i "UNIX Programmer's Manual"
E 3
I 3
Computer Systems Research Group, 1986,
.i "UNIX Programmer's Manual, 4.3 Berkeley Software Distribution."
E 3
Computer Systems Research Group,
Department of Electrical Engineering and Computer Science,
University of California, Berkeley.
.)b
E 1
