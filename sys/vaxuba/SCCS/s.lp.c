h05012
s 00001/00001/00348
d D 7.1 86/06/05 01:11:24 mckusick 42 41
c 4.3BSD release version
e
s 00006/00005/00343
d D 6.8 86/02/23 23:17:15 karels 41 40
c lint
e
s 00001/00003/00347
d D 6.7 85/11/22 06:39:44 tef 40 39
c standard list of device addresses must be null terminated.
e
s 00007/00001/00343
d D 6.6 85/06/08 14:17:49 mckusick 39 38
c Add copyright
e
s 00001/00000/00343
d D 6.5 85/02/08 18:41:28 kupfer 38 37
c Include ioctl.h so that tty.h knows about size of window stuff.
e
s 00010/00010/00333
d D 6.4 84/08/29 20:08:38 bloom 37 36
c Change to includes.  No more ../h
e
s 00009/00008/00334
d D 6.3 84/08/22 15:21:55 mckusick 36 35
c clean up spl's
e
s 00001/00001/00341
d D 6.2 84/08/02 16:51:32 mckusick 35 34
c fix for slow devices (from hplabs!tymix!feldman)
e
s 00000/00000/00342
d D 6.1 83/07/29 07:28:02 sam 34 33
c 4.2 distribution
e
s 00003/00002/00339
d D 4.33 83/06/13 23:01:14 sam 33 32
c lint
e
s 00009/00011/00332
d D 4.32 83/01/03 18:29:36 sam 32 31
c purge some crud; make max column size a configurable parameter
e
s 00001/00001/00342
d D 4.31 82/12/17 12:02:45 sam 31 30
c sun merge
e
s 00005/00010/00338
d D 4.30 82/10/17 11:49:27 root 30 29
c ioctl/open return errors, not u.u_error; remove ubarelses (it is
c now done in uba.c); add open routines to some disk drivers
e
s 00005/00003/00343
d D 4.29 82/10/10 22:37:44 root 29 28
c minor fixes relating to u.u_error handling
e
s 00002/00001/00344
d D 4.28 82/10/10 17:27:42 root 28 27
c header files for vax are in their place
e
s 00006/00003/00339
d D 4.27 82/08/22 21:18:36 root 27 26
c fully uio()'d
e
s 00001/00002/00341
d D 4.26 82/07/15 19:59:21 kre 26 25
c probe routines return size of unibus dev regs to reserve space
e
s 00002/00002/00341
d D 4.25 82/06/14 22:43:57 root 25 24
c geteblk needs a constant
e
s 00004/00000/00339
d D 4.24 82/05/04 13:38:35 sam 24 23
c CAD kludges and cleanup conf.c
e
s 00006/00000/00333
d D 4.23 82/04/14 15:20:55 sam 23 22
c ingres stuff
e
s 00000/00003/00333
d D 4.22 82/02/03 19:36:16 root 22 21
c dump old comments
e
s 00001/00000/00335
d D 4.21 81/11/18 15:49:41 wnj 21 20
c lint
e
s 00001/00000/00334
d D 4.20 81/07/25 21:34:49 wnj 20 19
c added missing return(1);
e
s 00007/00004/00327
d D 4.19 81/07/09 04:18:34 root 19 18
c lint
e
s 00000/00001/00331
d D 4.18 81/04/02 15:13:19 root 18 17
c now tested
e
s 00001/00001/00331
d D 4.17 81/03/21 15:54:15 wnj 17 16
c restore id keyw
e
s 00002/00002/00330
d D 4.16 81/03/21 15:52:00 wnj 16 15
c ci rk.c
e
s 00002/00002/00330
d D 4.15 81/03/14 19:20:11 wnj 15 14
c fix probe code to work
e
s 00062/00071/00270
d D 4.14 81/03/11 18:39:10 wnj 14 13
c cleanup
e
s 00000/00000/00341
d D 4.13 81/03/09 01:53:25 wnj 13 12
c %G% -> %E%
e
s 00006/00006/00335
d D 4.12 81/03/09 00:34:17 wnj 12 11
c lint
e
s 00014/00000/00327
d D 4.11 81/03/07 17:36:57 toy 11 10
c Added first stab at probe routine
e
s 00004/00000/00323
d D 4.10 81/03/07 01:32:00 toy 10 9
c Fixed up comment at start
e
s 00145/00122/00178
d D 4.9 81/03/07 01:30:03 toy 9 8
c Conversion to auto-config way of doing things.
e
s 00000/00002/00300
d D 4.8 81/03/02 12:58:44 toy 8 7
c Took out HALF ASCII stuff
e
s 00003/00003/00299
d D 4.7 81/02/27 03:14:48 wnj 7 6
c s/HZ/hz/
e
s 00002/00002/00300
d D 4.6 81/02/16 21:00:16 wnj 6 5
c NLP -> NLP11
e
s 00008/00020/00294
d D 4.5 81/01/20 09:29:11 toy 5 4
c Changed to eric allman's lp driver.  (MCT)
e
s 00016/00017/00298
d D 4.4 80/12/26 12:21:16 wnj 4 3
c fixes per epa
e
s 00001/00001/00314
d D 4.3 80/12/19 11:45:51 wnj 3 2
c s,../conf/,,
e
s 00000/00004/00315
d D 4.2 80/12/18 03:30:56 wnj 2 1
c remove mail wrapper
e
s 00319/00000/00000
d D 4.1 80/12/17 23:37:34 wnj 1 0
c date and time created 80/12/17 23:37:34 by wnj
e
u
U
t
T
I 1
D 2
From IngVAX:root  Wed Apr  9 02:43:54 1980
To: vax:bill

E 2
D 5
/*	%M%	%I%	%G%	*/
E 5
I 5
D 6
/*	lp.c	4.6	12/31/80	*/
E 6
I 6
D 16
/*	%M%	%I%	%E%	*/
E 16
I 16
D 17
/*	lp.c	4.15	81/03/14	*/
E 17
I 17
D 39
/*	%M%	%I%	%E%	*/
E 39
I 39
/*
D 42
 * Copyright (c) 1982 Regents of the University of California.
E 42
I 42
 * Copyright (c) 1982, 1986 Regents of the University of California.
E 42
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	%W% (Berkeley) %G%
 */
E 39
E 17
E 16
E 6
E 5

D 3
#include "../conf/lp.h"
E 3
I 3
#include "lp.h"
E 3
D 6
#if NLP > 0
E 6
I 6
D 9
#if NLP11 > 0
E 9
I 9
#if NLP > 0
E 9
E 6
/*
 * LP-11 Line printer driver
 *
D 9
 * This driver is only set up to handle one printer;
 * thats all our user-level spoolers can handle anyways right now.
 *
E 9
 * This driver has been modified to work on printers where
 * leaving IENABLE set would cause continuous interrupts.
I 10
D 22
 *
 * TODO:
D 18
 *	Test driver
E 18
 *	Test driver on multiple printers
E 22
E 10
 */
I 31
#include "../machine/pte.h"
E 31

D 37
#include "../h/param.h"
#include "../h/dir.h"
#include "../h/user.h"
#include "../h/buf.h"
#include "../h/systm.h"
#include "../h/map.h"
I 32
#include "../h/uio.h"
#include "../h/tty.h"
#include "../h/kernel.h"
E 37
I 37
#include "param.h"
#include "dir.h"
#include "user.h"
#include "buf.h"
#include "systm.h"
#include "map.h"
#include "uio.h"
I 38
#include "ioctl.h"
E 38
#include "tty.h"
#include "kernel.h"
E 37
E 32
D 31
#include "../h/pte.h"
E 31
D 9
#include "../h/uba.h"
E 9
I 9
D 28
#include "../h/ubavar.h"
E 28
E 9
D 30
#include "../h/ioctl.h"
#include "../h/tty.h"
E 30
I 28

D 37
#include "../vaxuba/ubavar.h"
E 37
I 37
#include "ubavar.h"
E 37
E 28
D 9
#include "../h/lpio.h"
E 9

#define	LPPRI	(PZERO+8)
#define	IENABLE	0100
#define	DONE	0200
#define	ERROR	0100000
#define	LPLWAT	650
#define	LPHWAT	800

I 24
D 32
#ifndef CAD
E 32
E 24
D 9
struct lpregs {
E 9
I 9
D 41
#define MAXCOL	132
I 24
D 32
#else
#define	MAXCOL	512
#endif
E 32
E 24
#define CAP	1
E 41
I 41
#define	LPBUFSIZE	1024
#define MAXCOL		132
#define CAP		1
E 41

D 41
#define LPUNIT(dev) (minor(dev) >> 3)
E 41
I 41
#define LPUNIT(dev)	(minor(dev) >> 3)
E 41

struct lpdevice {
E 9
	short	lpsr;
	short	lpbuf;
};

D 9
struct {
	struct	clist outq;
	int	state;
	int	physcol;
	int	logcol;
	int	physline;
	struct	lpioctl lpio;
	struct	buf *inbuf;
} lp11;
#define	flags	lpio.lp_flags
D 5
#define	ejline	lpio.lp_ejline
E 5
#define	indent	lpio.lp_indent
#define	maxcol	lpio.lp_maxcol
E 9
I 9
struct lp_softc {
	struct	clist sc_outq;
	int	sc_state;
	int	sc_physcol;
	int	sc_logcol;
	int	sc_physline;
	char	sc_flags;
I 32
	short	sc_maxcol;
E 32
	int	sc_lpchar;
	struct	buf *sc_inbuf;
} lp_softc[NLP];
E 9
D 5
#define	skpline	lpio.lp_skpline
E 5

I 9
struct uba_device *lpinfo[NLP];

int lpprobe(), lpattach(), lptout();
D 40
u_short lpstd[] = { 0177514 };
E 40
I 40
u_short lpstd[] = { 0177514, 0 };
E 40
struct uba_driver lpdriver =
	{ lpprobe, 0, lpattach, 0, lpstd, "lp", lpinfo };

E 9
/* bits for state */
#define	OPEN		1	/* device is open */
#define	TOUT		2	/* timeout is active */
#define	MOD		4	/* device state has been modified */
#define	ASLP		8	/* awaiting draining of printer */
D 40

D 32
extern	lbolt;
E 32
int	lptout();
E 40

I 14
lpattach(ui)
	struct uba_device *ui;
{
	register struct lp_softc *sc;

	sc = &lp_softc[ui->ui_unit];
	sc->sc_lpchar = -1;
I 32
	if (ui->ui_flags)
		sc->sc_maxcol = ui->ui_flags;
	else
		sc->sc_maxcol = MAXCOL;
E 32
}

lpprobe(reg)
	caddr_t reg;
{
I 15
	register int br, cvec;			/* value-result */
E 15
	register struct lpdevice *lpaddr = (struct lpdevice *)reg;
I 19
#ifdef lint
	br = 0; cvec = br; br = cvec;
I 21
	lpintr(0);
E 21
#endif
E 19

I 23
D 32
#ifdef INGVAX
	br = 0x14;
	cvec = 0200;
D 26
	return (1);
E 26
#else
E 32
E 23
	lpaddr->lpsr = IENABLE;
D 15
	lpaddr->lpbuf = ' ';
	DELAY(10000);
E 15
I 15
	DELAY(5);
E 15
	lpaddr->lpsr = 0;
I 20
D 26
	return (1);
E 26
I 23
D 32
#endif
E 32
I 26
	return (sizeof (struct lpdevice));
E 26
E 23
E 20
}

E 14
/*ARGSUSED*/
lpopen(dev, flag)
I 9
D 14
dev_t dev;
E 14
I 14
	dev_t dev;
	int flag;
E 14
E 9
{
I 9
D 36
	register int unit;
E 36
	register struct lpdevice *lpaddr;
	register struct lp_softc *sc;
	register struct uba_device *ui;
I 36
	register int unit, s;
E 36
E 9

D 9
	if (lp11.state&OPEN || LPADDR->lpsr&ERROR) {
E 9
I 9
D 14
	if ((unit = LPUNIT(dev)) >= NLP)
	{
E 14
I 14
	if ((unit = LPUNIT(dev)) >= NLP ||
	    (sc = &lp_softc[unit])->sc_state&OPEN ||
D 30
	    (ui = lpinfo[unit]) == 0 || ui->ui_alive == 0) {
E 14
		u.u_error = ENXIO;
		return;
	}
E 30
I 30
	    (ui = lpinfo[unit]) == 0 || ui->ui_alive == 0)
		return (ENXIO);
E 30
D 14
	sc = &lp_softc[unit];
	ui = lpinfo[unit];
	lpaddr = (struct lpdevice *) ui->ui_addr;
	if (sc->sc_state&OPEN || lpaddr->lpsr&ERROR) {
E 14
I 14
	lpaddr = (struct lpdevice *)ui->ui_addr;
D 30
	if (lpaddr->lpsr&ERROR) {
E 14
E 9
		u.u_error = EIO;
		return;
	}
E 30
I 30
	if (lpaddr->lpsr&ERROR)
		return (EIO);
E 30
D 9
	lp11.state |= OPEN;
	lp11.inbuf = geteblk();
	lp11.flags = LPFLAGS;
D 5
	lp11.ejline = EJLINE;
E 5
	lp11.indent = INDENT;
	lp11.maxcol = MAXCOL;
E 9
I 9
	sc->sc_state |= OPEN;
D 25
	sc->sc_inbuf = geteblk();
E 25
I 25
D 41
	sc->sc_inbuf = geteblk(512);
E 41
I 41
	sc->sc_inbuf = geteblk(LPBUFSIZE);
E 41
E 25
	sc->sc_flags = minor(dev) & 07;
E 9
D 5
	lp11.skpline = SKPLINE;
E 5
D 12
	spl4();
E 12
I 12
D 36
	(void) spl4();
E 36
I 36
	s = spl4();
E 36
E 12
D 9
	if ((lp11.state&TOUT) == 0) {
		lp11.state |= TOUT;
D 7
		timeout(lptout, 0, 10*HZ);
E 7
I 7
		timeout(lptout, 0, 10*hz);
E 9
I 9
	if ((sc->sc_state&TOUT) == 0) {
		sc->sc_state |= TOUT;
D 19
		timeout(lptout, dev, 10*hz);
E 19
I 19
		timeout(lptout, (caddr_t)dev, 10*hz);
E 19
E 9
E 7
	}
D 12
	spl0();
E 12
I 12
D 36
	(void) spl0();
E 36
I 36
	splx(s);
E 36
E 12
D 14
	lpcanon('\f');
E 14
I 14
	lpcanon(dev, '\f');
I 30
	return (0);
E 30
E 14
}

/*ARGSUSED*/
lpclose(dev, flag)
I 9
D 14
dev_t dev;
E 14
I 14
	dev_t dev;
	int flag;
E 14
E 9
{
I 9
D 14
	register struct lp_softc *sc;
E 14
I 14
	register struct lp_softc *sc = &lp_softc[LPUNIT(dev)];
E 14
E 9

I 9
D 14
	sc = &lp_softc[LPUNIT(dev)];
E 9
I 5
	lpcanon('\f');
E 14
I 14
	lpcanon(dev, '\f');
E 14
E 5
D 9
	brelse(lp11.inbuf);
	lp11.state &= ~OPEN;
E 9
I 9
	brelse(sc->sc_inbuf);
	sc->sc_state &= ~OPEN;
E 9
D 4
	lpcanon('\f');
E 4
I 4
D 5
	lpcanon('\r');
	lpoutput('\f');
E 5
E 4
}

D 9
lpwrite()
E 9
I 9
D 27
lpwrite(dev)
E 27
I 27
lpwrite(dev, uio)
E 27
D 14
register dev_t dev;
E 14
I 14
	dev_t dev;
I 27
	struct uio *uio;
E 27
E 14
E 9
{
D 9
	register c, n;
E 9
I 9
D 19
	register int n;
E 19
I 19
	register unsigned n;
E 19
E 9
	register char *cp;
I 9
D 14
	register struct lp_softc *sc;
E 14
I 14
	register struct lp_softc *sc = &lp_softc[LPUNIT(dev)];
I 29
	int error;
E 29
E 14
E 9

I 9
D 14
	sc = &lp_softc[LPUNIT(dev)];
E 14
E 9
D 25
	while (n = min(BSIZE, u.u_count)) {
E 25
I 25
D 27
	while (n = min(512, u.u_count)) {
E 27
I 27
D 33
	while (n = min(512, uio->uio_resid)) {
E 33
I 33
D 41
	while (n = min(512, (unsigned)uio->uio_resid)) {
E 41
I 41
	while (n = MIN(LPBUFSIZE, (unsigned)uio->uio_resid)) {
E 41
E 33
E 27
E 25
D 9
		cp = lp11.inbuf->b_un.b_addr;
E 9
I 9
		cp = sc->sc_inbuf->b_un.b_addr;
E 9
D 27
		iomove(cp, n, B_WRITE);
E 27
I 27
D 29
		u.u_error = uiomove(cp, n, UIO_WRITE, uio);
		if (u.u_error)
			break;
E 29
I 29
D 33
		error = uiomove(cp, n, UIO_WRITE, uio);
E 33
I 33
		error = uiomove(cp, (int)n, UIO_WRITE, uio);
E 33
		if (error)
			return (error);
E 29
E 27
		do
D 9
			lpcanon(*cp++);
E 9
I 9
D 14
			lpcanon(*cp++, dev);
E 14
I 14
			lpcanon(dev, *cp++);
E 14
E 9
		while (--n);
	}
I 29
	return (0);
E 29
}

D 9
lpcanon(c)
register c;
E 9
I 9
D 14
lpcanon(c, dev)
register int c;
register dev_t dev;
E 14
I 14
lpcanon(dev, c)
	dev_t dev;
	register int c;
E 14
E 9
{
D 36
	register int logcol, physcol;
E 36
I 9
D 14
	register struct lp_softc *sc;
E 14
I 14
	register struct lp_softc *sc = &lp_softc[LPUNIT(dev)];
I 36
	register int logcol, physcol, s;
E 36
E 14
E 9

D 8
#ifdef HALFASCII
E 8
D 9
	if (lp11.flags&CAP) {
E 9
I 9
D 14
	sc = &lp_softc[LPUNIT(dev)];
E 14
	if (sc->sc_flags&CAP) {
E 9
		register c2;

		if (c>='a' && c<='z')
			c += 'A'-'a'; else
		switch (c) {

		case '{':
			c2 = '(';
			goto esc;

		case '}':
			c2 = ')';
			goto esc;

		case '`':
			c2 = '\'';
			goto esc;

		case '|':
			c2 = '!';
			goto esc;

		case '~':
			c2 = '^';

		esc:
D 9
			lpcanon(c2);
			lp11.logcol--;
E 9
I 9
D 14
			lpcanon(c2, dev);
E 14
I 14
			lpcanon(dev, c2);
E 14
			sc->sc_logcol--;
E 9
			c = '-';
		}
	}
D 8
#endif HALFASCII
E 8
D 9
	logcol = lp11.logcol;
	physcol = lp11.physcol;
E 9
I 9
	logcol = sc->sc_logcol;
	physcol = sc->sc_physcol;
E 9
	if (c == ' ')
		logcol++;
	else switch(c) {

	case '\t':
D 9
		logcol = lp11.indent + ((logcol-lp11.indent+8) & ~7);
E 9
I 9
D 16
		logcol = (logcol-8) & ~7;
E 16
I 16
		logcol = (logcol+8) & ~7;
E 16
E 9
		break;

D 5
	case '\n':
D 4
		lp11.physline++;
		if (lp11.physline >= lp11.ejline)
E 4
I 4
		if (lp11.physline >= lp11.ejline && (lp11.flags & SKIPFOLD))
E 4
			c = '\f';
		/* fall through */

E 5
	case '\f':
I 4
D 5
		if (lp11.physline == 0 && physcol == 0 && (lp11.flags & SKIPFOLD))
E 5
I 5
D 9
		if (lp11.physline == 0 && physcol == 0)
E 9
I 9
		if (sc->sc_physline == 0 && physcol == 0)
E 9
E 5
			break;
E 4
D 5
		physcol = 0;
E 5
I 5
		/* fall into ... */

	case '\n':
E 5
D 4
		if (lp11.physline == 0 && (lp11.flags&SAVEPAPER))
			;
		else {
			lpoutput(c);
			if (c == '\f') {
				lp11.physline = 0;
				if (lp11.flags & SKIPFOLD) {
					int i;
					for (i = 0; i < lp11.skpline; i++)
						lpoutput('\n');
				}
			}
		}
E 4
I 4
D 9
		lpoutput(c);
E 9
I 9
D 14
		lpoutput(c, dev);
E 14
I 14
		lpoutput(dev, c);
E 14
E 9
		if (c == '\f')
D 9
			lp11.physline = 0;
E 9
I 9
			sc->sc_physline = 0;
E 9
		else
D 9
			lp11.physline++;
E 9
I 9
			sc->sc_physline++;
E 9
I 5
		physcol = 0;
E 5
E 4
		/* fall into ... */

	case '\r':
I 36
		s = spl4();
E 36
D 9
		logcol = lp11.indent;
E 9
I 9
		logcol = 0;
E 9
D 12
		spl4();
E 12
I 12
D 36
		(void) spl4();
E 36
E 12
D 9
		lpintr();
E 9
I 9
D 14
		lpintr(dev);
E 14
I 14
		lpintr(LPUNIT(dev));
E 14
E 9
D 12
		spl0();
E 12
I 12
D 36
		(void) spl0();
E 36
I 36
		splx(s);
E 36
E 12
		break;

	case '\b':
		if (logcol > 0)
			logcol--;
		break;

	default:
I 4
D 5
		if (lp11.physline == 0 && (lp11.flags & SKIPFOLD)) {
			int i;
			lp11.physline = lp11.skpline;
			for (i = 0; i < lp11.skpline; i++)
				lpoutput('\n');
		}
E 5
E 4
		if (logcol < physcol) {
D 9
			lpoutput('\r');
E 9
I 9
D 14
			lpoutput('\r', dev);
E 14
I 14
			lpoutput(dev, '\r');
E 14
E 9
			physcol = 0;
		}
D 9
		if (logcol < lp11.maxcol) {
E 9
I 9
D 32
		if (logcol < MAXCOL) {
E 32
I 32
		if (logcol < sc->sc_maxcol) {
E 32
E 9
			while (logcol > physcol) {
D 14
				lpoutput(' ');
E 14
I 14
				lpoutput(dev, ' ');
E 14
				physcol++;
			}
D 9
			lpoutput(c);
E 9
I 9
D 14
			lpoutput(c, dev);
E 14
I 14
			lpoutput(dev, c);
E 14
E 9
			physcol++;
		}
		logcol++;
	}
	if (logcol > 1000)	/* ignore long lines  */
		logcol = 1000;
D 9
	lp11.logcol = logcol;
	lp11.physcol = physcol;
E 9
I 9
	sc->sc_logcol = logcol;
	sc->sc_physcol = physcol;
E 9
}

D 9
lpoutput(c)
E 9
I 9
D 14
lpoutput(c, dev)
dev_t dev;
E 14
I 14
lpoutput(dev, c)
	dev_t dev;
	int c;
E 14
E 9
{
I 9
D 14
	register struct lp_softc *sc;
E 14
I 14
	register struct lp_softc *sc = &lp_softc[LPUNIT(dev)];
I 36
	int s;
E 36
E 14
E 9

D 9
	if (lp11.outq.c_cc >= LPHWAT) {
E 9
I 9
D 14
	sc = &lp_softc[LPUNIT(dev)];
E 14
	if (sc->sc_outq.c_cc >= LPHWAT) {
E 9
D 12
		spl4();
E 12
I 12
D 36
		(void) spl4();
E 36
I 36
		s = spl4();
E 36
E 12
D 9
		lpintr();				/* unchoke */
		while (lp11.outq.c_cc >= LPHWAT) {
			lp11.state |= ASLP;		/* must be ERROR */
			sleep((caddr_t)&lp11, LPPRI);
E 9
I 9
D 14
		lpintr(dev);				/* unchoke */
E 14
I 14
		lpintr(LPUNIT(dev));				/* unchoke */
E 14
		while (sc->sc_outq.c_cc >= LPHWAT) {
			sc->sc_state |= ASLP;		/* must be ERROR */
			sleep((caddr_t)sc, LPPRI);
E 9
		}
D 12
		spl0();
E 12
I 12
D 36
		(void) spl0();
E 36
I 36
		splx(s);
E 36
E 12
	}
D 9
	while (putc(c, &lp11.outq))
E 9
I 9
	while (putc(c, &sc->sc_outq))
E 9
		sleep((caddr_t)&lbolt, LPPRI);
}

D 9
int	lpchar = -1;

lpintr()
E 9
I 9
D 14
lpintr(dev)
dev_t dev;
E 14
I 14
lpintr(lp11)
	int lp11;
E 14
E 9
{
	register int n;
D 9
	int i;
E 9
I 9
D 14
	register struct lp_softc *sc;
	register struct lpdevice *lpaddr;
	register struct uba_device *ui;
E 14
I 14
	register struct lp_softc *sc = &lp_softc[lp11];
	register struct uba_device *ui = lpinfo[lp11];
	register struct lpdevice *lpaddr = (struct lpdevice *)ui->ui_addr;
E 14
E 9

D 9
	LPADDR->lpsr &= ~IENABLE;
	n = lp11.outq.c_cc;
	if (lpchar < 0)
		lpchar = getc(&lp11);
	while ((LPADDR->lpsr&DONE) && lpchar >= 0) {
		LPADDR->lpbuf = lpchar;
		lpchar = getc(&lp11);
E 9
I 9
D 14
	sc = &lp_softc[LPUNIT(dev)];
	ui = lpinfo[LPUNIT(dev)];
	lpaddr = (struct lpdevice *) ui->ui_addr;
E 14
	lpaddr->lpsr &= ~IENABLE;
	n = sc->sc_outq.c_cc;
	if (sc->sc_lpchar < 0)
		sc->sc_lpchar = getc(&sc->sc_outq);
	while ((lpaddr->lpsr&DONE) && sc->sc_lpchar >= 0) {
		lpaddr->lpbuf = sc->sc_lpchar;
		sc->sc_lpchar = getc(&sc->sc_outq);
E 9
	}
D 4
nomore:
E 4
D 9
	lp11.state |= MOD;
	if (lp11.outq.c_cc > 0 && (LPADDR->lpsr&ERROR)==0)
		LPADDR->lpsr |= IENABLE;	/* ok and more to do later */
	if (n>LPLWAT && lp11.outq.c_cc<=LPLWAT && lp11.state&ASLP) {
		lp11.state &= ~ASLP;
		wakeup((caddr_t)&lp11);		/* top half should go on */
E 9
I 9
	sc->sc_state |= MOD;
	if (sc->sc_outq.c_cc > 0 && (lpaddr->lpsr&ERROR)==0)
		lpaddr->lpsr |= IENABLE;	/* ok and more to do later */
	if (n>LPLWAT && sc->sc_outq.c_cc<=LPLWAT && sc->sc_state&ASLP) {
		sc->sc_state &= ~ASLP;
		wakeup((caddr_t)sc);		/* top half should go on */
E 9
	}
}

D 9
lptout()
E 9
I 9
lptout(dev)
D 14
register dev_t dev;
E 14
I 14
	dev_t dev;
E 14
E 9
{
D 9
	register short *sr;
E 9
I 9
	register struct lp_softc *sc;
	register struct uba_device *ui;
	register struct lpdevice *lpaddr;
E 9

D 9
	if ((lp11.state&MOD) != 0) {
		lp11.state &= ~MOD;		/* something happened */
D 7
		timeout(lptout, 0, 2*HZ);	/* so don't sweat */
E 7
I 7
		timeout(lptout, 0, 2*hz);	/* so don't sweat */
E 9
I 9
	sc = &lp_softc[LPUNIT(dev)];
	ui = lpinfo[LPUNIT(dev)];
	lpaddr = (struct lpdevice *) ui->ui_addr;
	if ((sc->sc_state&MOD) != 0) {
		sc->sc_state &= ~MOD;		/* something happened */
D 19
		timeout(lptout, dev, 2*hz);	/* so don't sweat */
E 19
I 19
		timeout(lptout, (caddr_t)dev, 2*hz);	/* so don't sweat */
E 19
E 9
E 7
		return;
	}
D 9
	sr = &LPADDR->lpsr;
	if ((lp11.state&OPEN) == 0) {
		lp11.state &= ~TOUT;		/* no longer open */
		*sr = 0;
E 9
I 9
D 35
	if ((sc->sc_state&OPEN) == 0) {
E 35
I 35
	if ((sc->sc_state&OPEN) == 0 && sc->sc_outq.c_cc == 0) {
E 35
		sc->sc_state &= ~TOUT;		/* no longer open */
		lpaddr->lpsr = 0;
E 9
		return;
	}
D 9
	if (lp11.outq.c_cc && (*sr&DONE) && (*sr&ERROR)==0)
		lpintr();			/* ready to go */
D 7
	timeout(lptout, 0, 10*HZ);
E 7
I 7
	timeout(lptout, 0, 10*hz);
E 9
I 9
	if (sc->sc_outq.c_cc && (lpaddr->lpsr&DONE) && (lpaddr->lpsr&ERROR)==0)
D 14
		lpintr(dev);			/* ready to go */
E 14
I 14
		lpintr(LPUNIT(dev));			/* ready to go */
E 14
D 19
	timeout(lptout, dev, 10*hz);
E 19
I 19
	timeout(lptout, (caddr_t)dev, 10*hz);
E 19
E 9
E 7
}

D 9
/*ARGSUSED*/
lpioctl(dev, cmd, addr, flag)
	dev_t dev;
	caddr_t addr;
E 9
I 9
lpreset(uban)
D 14
int uban;
E 14
I 14
	int uban;
E 14
E 9
{
D 9
	register int m;
	struct lpioctl lpio;
E 9
I 9
	register struct uba_device *ui;
	register struct lpdevice *lpaddr;
	register int unit;
E 9

D 9
	switch (cmd) {

	case LGETSTATE:
		copyout((caddr_t)&lp11.lpio, addr, sizeof (lp11.lpio));
		return;

	case LSETSTATE:
		m = copyin(addr, (caddr_t)&lpio, sizeof (lpio));
		if (m < 0) {
			u.u_error = EFAULT;
			return;
		}
		if (lpio.lp_indent <= 0 || lpio.lp_indent >= lpio.lp_maxcol ||
		    lpio.lp_ejline <= 2 || lpio.lp_ejline <= lpio.lp_skpline ||
		    lpio.lp_skpline < 0 || lpio.lp_maxcol <= 10)
			u.u_error = EINVAL;
		else
			lp11.lpio = lpio;
		return;

	default:
		u.u_error = ENOTTY;
		return;
E 9
I 9
D 14
	for (unit = 0; unit < NLP; unit++)
	{
		ui = lpinfo[unit];
		if (ui == 0 || ui->ui_ubanum != uban || ui->ui_alive == 0)
E 14
I 14
	for (unit = 0; unit < NLP; unit++) {
		if ((ui = lpinfo[unit]) == 0 || ui->ui_ubanum != uban ||
		    ui->ui_alive == 0)
E 14
			continue;
		printf(" lp%d", unit);
D 14
		lpaddr = (struct lpdevice *) ui->ui_addr;
E 14
I 14
		lpaddr = (struct lpdevice *)ui->ui_addr;
E 14
		lpaddr->lpsr |= IENABLE;
E 9
	}
D 14
}

D 9
lpreset()
E 9
I 9
lpattach(ui)
struct uba_device *ui;
E 9
{
I 9
	register struct lp_softc *sc;
E 9

D 9
	printf("lp ");
	LPADDR->lpsr |= IENABLE;
E 9
I 9
	sc = &lp_softc[ui->ui_unit];
	sc->sc_lpchar = -1;
E 9
}
I 11

lpprobe(reg)
caddr_t reg;
{
	register struct lpdevice *lpaddr;
	register int delay = 10000;

	lpaddr = (struct lpdevice *) reg;
	lpaddr->lpsr |= IENABLE;
	lpaddr->lpbuf = ' ';
	while(delay--)
		continue;
	lpaddr->lpsr &= ~IENABLE;
E 14
}
I 33
#endif
E 33
E 11
I 5
D 9

E 9
E 5
D 2

E 2
E 1
