h07750
s 00009/00010/00376
d D 7.4 88/05/26 09:37:17 karels 47 46
c lint
e
s 00041/00021/00345
d D 7.3 88/05/07 14:18:58 karels 46 45
c vax 8200 support from torek: generalize cpu support, ops, clock ops
e
s 00002/00003/00364
d D 7.2 87/06/20 12:11:07 mckusick 45 44
c camap is replaced by kmempt
e
s 00001/00001/00366
d D 7.1 86/06/05 00:39:57 mckusick 44 43
c 4.3BSD release version
e
s 00009/00001/00358
d D 6.10 86/06/02 14:36:25 karels 43 42
c lint
e
s 00011/00004/00348
d D 6.9 86/04/22 10:51:11 kridle 42 41
c Added MicroVAX II Support (KA630)
e
s 00007/00001/00345
d D 6.8 86/02/23 23:05:55 karels 41 40
c lint
e
s 00003/00003/00343
d D 6.7 85/12/19 16:09:57 karels 40 39
c rm bbnnet
e
s 00001/00001/00345
d D 6.6 85/10/15 20:08:15 mckusick 39 38
c get the semantics right (from Torek, of course)
e
s 00098/00043/00248
d D 6.5 85/09/09 23:26:37 sam 38 37
c update for 4.3
e
s 00007/00001/00284
d D 6.4 85/06/08 13:38:49 mckusick 37 36
c Add copyright
e
s 00014/00014/00271
d D 6.3 84/08/28 18:08:02 bloom 36 35
c Change to includes.  No more ../h
e
s 00002/00002/00283
d D 6.2 84/02/15 11:52:07 karels 35 34
c consistency checks and data structures based on NUBA, not half MAXNUBA
e
s 00000/00000/00285
d D 6.1 83/08/11 19:31:25 sam 34 33
c 4.2 distribution
e
s 00001/00000/00284
d D 4.27 83/08/11 19:31:10 sam 33 30
c must include uba.h
e
s 00000/00000/00284
d R 6.1 83/08/01 12:07:45 sam 32 30
c 4.2 distribution
e
s 00000/00000/00284
d R 4.27 83/08/01 12:04:34 sam 31 30
c 4.2 distribution
e
s 00006/00000/00278
d D 4.26 83/08/01 12:02:34 sam 30 28
c add support for second uba on 750; move rpb in front of 
c scb, otherwise it would be at variable location; add nexi numbers 
c for 64K chip controllers and ci
e
s 00000/00000/00278
d R 6.1 83/07/29 07:18:59 sam 29 28
c 4.2 distribution
e
s 00028/00000/00250
d D 4.25 83/06/13 23:02:01 sam 28 27
c lint
e
s 00018/00000/00232
d D 4.24 83/05/27 13:48:12 sam 27 26
c lint
e
s 00002/00001/00230
d D 4.23 82/12/17 11:55:11 sam 26 25
c sun merge
e
s 00006/00000/00225
d D 4.22 82/11/13 22:58:22 sam 25 24
c merge of 4.1b with 4.1c
e
s 00006/00002/00219
d D 4.21 82/10/17 23:04:57 root 24 23
c lint
e
s 00002/00005/00219
d D 4.20 82/10/17 15:24:38 root 23 22
c fix lint
e
s 00004/00003/00220
d D 4.19 82/10/13 22:12:34 root 22 21
c rearrange header files
e
s 00001/00001/00222
d D 4.18 82/06/27 10:46:23 root 21 20
c use masterpaddr
e
s 00000/00000/00223
d D 4.17 81/12/02 17:26:06 wnj 20 19
c more cleanup
e
s 00004/00003/00219
d D 4.16 81/11/29 22:20:46 wnj 19 18
c weekend editing
e
s 00004/00000/00218
d D 4.15 81/11/20 14:42:35 wnj 18 17
c more lint
e
s 00001/00000/00217
d D 4.14 81/11/18 15:44:34 wnj 17 16
c more cleanup
e
s 00006/00004/00211
d D 4.13 81/11/16 14:20:01 wnj 16 15
c lint
e
s 00001/00001/00214
d D 4.12 81/08/29 23:11:33 bugs 15 14
c fix arg order of bcopy
e
s 00002/00000/00213
d D 4.11 81/05/15 10:32:33 root 14 13
c masterpaddr added
e
s 00001/00000/00212
d D 4.10 81/05/05 21:49:50 wnj 13 12
c initialize boothowto
e
s 00002/00003/00210
d D 4.9 81/04/28 02:50:56 root 12 11
c fixes for lint's sake
e
s 00001/00001/00212
d D 4.8 81/03/09 01:46:28 wnj 11 10
c lint and a few minor fixed
e
s 00039/00018/00174
d D 4.7 81/03/09 00:31:47 wnj 10 9
c lint
e
s 00000/00005/00192
d D 4.6 81/02/27 02:39:19 wnj 9 8
c before compiling dynamic version
e
s 00105/00222/00092
d D 4.5 81/02/21 21:33:11 wnj 8 7
c first attempt at lintability
e
s 00004/00008/00310
d D 4.4 80/11/10 09:41:45 bill 7 6
c minor lint
e
s 00007/00030/00311
d D 4.3 80/11/09 23:47:00 bill 6 5
c more cleanup for 4bsd
e
s 00111/00031/00230
d D 4.2 80/11/09 17:46:48 bill 5 4
c clean up for 4bsd
e
s 00000/00000/00261
d D 4.1 80/11/09 17:31:16 bill 4 3
c minor fixups to restart stuff; version 4.1 for distrib
e
s 00001/00001/00260
d D 3.3 80/06/07 02:44:12 bill 3 2
c %H%->%G%
e
s 00001/00001/00260
d D 3.2 80/04/11 10:15:18 bill 2 1
c Sysmap now 6 pages
e
s 00261/00000/00000
d D 3.1 80/04/09 16:02:48 bill 1 0
c date and time created 80/04/09 16:02:48 by bill
e
u
U
t
T
I 1
D 3
/*	%M%	%I%	%H%	*/
E 3
I 3
D 11
/*	%M%	%I%	%G%	*/
E 11
I 11
D 37
/*	%M%	%I%	%E%	*/
E 37
I 37
/*
D 44
 * Copyright (c) 1982 Regents of the University of California.
E 44
I 44
 * Copyright (c) 1982, 1986 Regents of the University of California.
E 44
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	%W% (Berkeley) %G%
 */
E 37
E 11
E 3

I 10
#include "dz.h"
I 18
#include "mba.h"
I 33
#include "uba.h"
E 33
E 18

I 26
D 36
#include "../machine/pte.h"
E 36
I 36
#include "pte.h"
E 36

E 26
E 10
D 36
#include "../h/param.h"
#include "../h/systm.h"
#include "../h/dir.h"
#include "../h/user.h"
D 26
#include "../h/pte.h"
E 26
#include "../h/vm.h"
#include "../h/tty.h"
D 9
#include "../h/cmap.h"
E 9
I 6
#include "../h/proc.h"
I 8
#include "../h/buf.h"
D 10
#include "../h/uba.h"
E 10
I 10
D 22
#include "../h/ubavar.h"
#include "../h/ubareg.h"
#include "../h/nexus.h"
E 22
#include "../h/msgbuf.h"
I 17
#include "../h/mbuf.h"
I 28
#include "../h/protosw.h"
#include "../h/domain.h"
E 36
I 36
#include "param.h"
#include "systm.h"
#include "dir.h"
#include "user.h"
#include "vm.h"
I 38
#include "ioctl.h"
E 38
#include "tty.h"
#include "proc.h"
#include "buf.h"
#include "msgbuf.h"
#include "mbuf.h"
#include "protosw.h"
#include "domain.h"
I 38
#include "map.h"
I 46
#include "dkbad.h"
E 46
E 38
E 36
E 28
I 22

I 46
#include "scb.h"
E 46
D 36
#include "../vax/nexus.h"
E 36
I 36
#include "nexus.h"
I 41
#include "ioa.h"
I 42
D 46
#include "ka630.h"
E 46
E 42
E 41
E 36
#include "../vaxuba/ubavar.h"
#include "../vaxuba/ubareg.h"
E 22
E 17
E 10
E 8
E 6

/*
 * Pseudo file for lint to show what is used/defined in locore.s.
 */
D 8

int	printsw;
int	coresw;
E 8
D 9
struct	cmap *cmap;
struct	cmap *ecmap;
E 9

I 8
D 46
struct	scb scb;
E 46
I 46
struct	scb scb[1];
E 46
D 47
int	(*UNIvec[128])();
I 30
#if NUBA > 1
int	(*UNI1vec[128])();
#endif
E 47
I 47
int	(*UNIvec[NUBA][128])();		/* unibus vec for ubas */
int	(*eUNIvec)();			/* end of unibus vec */
E 47
E 30
struct	rpb rpb;
D 38
int	intstack[3*128];

E 38
I 38
int	dumpflag;
int	intstack[3*NBPG];
E 38
I 14
int	masterpaddr;		/* p_addr of current process on master cpu */
D 38

E 38
E 14
struct	user u;
I 38
int	icode[8];
int	szicode = sizeof (icode);
/*
 * Variables declared for savecore, or
 * implicitly, such as by config or the loader.
 */
D 46
char	version[] = "4.2 BSD UNIX ....";
E 46
I 46
char	version[] = "4.3 BSD UNIX ....";
E 46
int	etext;
E 38

doadump() { dumpsys(); }

I 46
#if NMBA > 0
E 46
Xmba3int() { }
Xmba2int() { }
Xmba1int() { }
Xmba0int() { }
I 46
#endif
E 46

D 10
#if VAX780
Xuba3int() { }
Xuba2int() { }
Xuba1int() { }
Xuba0int() { }
#endif

E 10
E 8
lowinit()
{
I 38
#if !defined(GPROF)
	caddr_t cp;
#endif
E 38
I 27
	extern int dumpmag;
I 38
	extern int rthashsize;
	extern int arptab_size;
	extern int dk_ndrive;
E 38
I 28
	extern struct domain unixdomain;
D 46
#ifdef PUP
	extern struct domain pupdomain;
#endif
E 46
D 38
#ifdef INET
E 38
I 38
D 40
#if defined(INET) || defined(BBNNET)
E 40
I 40
#ifdef INET
E 40
E 38
	extern struct domain inetdomain;
#endif
#include "imp.h"
#if NIMP > 0
	extern struct domain impdomain;
#endif
I 38
#ifdef NS
	extern struct domain nsdomain;
#endif
E 38
E 28
E 27
D 8
	extern	int (*UNIvec[BSIZE/NBPW])();
E 8

I 28
	/* cpp messes these up for lint so put them here */
	unixdomain.dom_next = domains;
	domains = &unixdomain;
D 46
#ifdef PUP
	pupdomain.dom_next = domains;
	domains = &pupdomain;
#endif
E 46
D 38
#ifdef INET
E 38
I 38
D 40
#if defined(INET) || defined(BBNNET)
E 40
I 40
#ifdef INET
E 40
E 38
	inetdomain.dom_next = domains;
	domains = &inetdomain;
#endif
#if NIMP > 0
	impdomain.dom_next = domains;
	domains = &impdomain;
#endif
I 38
#ifdef NS
	nsdomain.dom_next = domains;
	domains = &nsdomain;
#endif
E 38
E 28
I 27
	dumpmag = 0;			/* used only by savecore */
I 38
	rthashsize = rthashsize;	/* used by netstat, etc. */
	arptab_size = arptab_size;	/* used by arp command */
	dk_ndrive = dk_ndrive;		/* used by vmstat, iostat, etc. */
E 38

E 27
	/*
	 * Pseudo-uses of globals.
	 */
	lowinit();
	intstack[0] = intstack[1];
I 10
	rpb = rpb;
E 10
D 8
	Sysmap[0] = Sysmap[1];
E 8
I 8
D 46
	scb = scb;
E 46
I 46
	scb[0] = scb[0];
E 46
E 8
	maxmem = physmem = freemem = 0;
D 8
	/* should reference _u */
E 8
I 8
	u = u;
	fixctlrmask();
E 8
	main(0);
I 16
	Xustray();
E 16

	/*
	 * Routines called from interrupt vectors.
	 */
D 8
	dump();
	hpintr(0, 0);
	htintr(0, 0);
E 8
I 8
	panic("Machine check");
	printf("Write timeout");
E 8
D 47
	(*UNIvec[0])();
I 30
#if NUBA > 1
	(*UNI1vec[0])();
#endif
E 47
I 47
	(*UNIvec[0][0])();
E 47
E 30
D 8
	printf("error!");
E 8
I 8
	ubaerror(0, (struct uba_hd *)0, 0, 0, (struct uba_regs *)0);
E 8
	cnrint(0);
	cnxint(0);
I 10
	consdin();
	consdout();
#if NDZ > 0
	dzdma();
I 18
#endif
#if NMBA > 0
	mbintr(0);
E 18
#endif
I 46
#if VAX8200			/* XXX wrong conditional */
	bi_buserr(0);
#endif
#if VAX8200
	rxcdintr();
	rx50intr();
#endif
E 46
E 10
D 8
	clock((caddr_t)0, 0);
	if (runrun)
		;
E 8
I 8
	hardclock((caddr_t)0, 0);
I 10
	softclock((caddr_t)0, 0);
E 10
E 8
	trap(0, 0, (unsigned)0, 0, 0);
	syscall(0, 0, (unsigned)0, 0, 0);
I 16
D 19
	netintr();
E 19
I 19
D 38
	ipintr();
E 38
	rawintr();
I 38
D 40
#if defined(INET) || defined(BBNNET)
E 40
I 40
#ifdef INET
E 40
	ipintr();
#endif
#ifdef NS
	nsintr();
#endif
I 46
	machinecheck((caddr_t)0);
	memerr();
E 46
E 38
E 19
E 16
I 10

I 46
	/*
	 * Miscellaneous routines called from configurable
	 * drivers.
	 */
	ubapurge((struct uba_ctlr *)0);
	ubattydma(0);
	(void) ubamem(0, 0, 16, 1);
	(void) isbad((struct dkbad *)0, 0, 0, 0);
	disksort((struct buf *)0, (struct buf *)0);
	(void) uwritec((struct uio *)0);
	(void) todr();
E 46
	if (vmemall((struct pte *)0, 0, (struct proc *)0, 0))
		return;		/* use value */
D 16
	if (forceclose((dev_t)0))
		return;		/* use value */
E 16
D 46
	machinecheck((caddr_t)0);
	memerr();
E 46
I 13
	boothowto = 0;
I 38
	dumpflag = 0; dumpflag = dumpflag;
I 47
#ifdef KADB
E 47
I 46
	bootesym = 0; bootesym = bootesym;
I 47
#endif
E 47
E 46
#if !defined(GPROF)
	cp = (caddr_t)&etext;
	cp = cp;
#endif
E 38
E 13
E 10
I 7
D 8
	dumptrc();
E 8
E 7
}

D 8
dzdma()
{
E 8
I 8
consdin() { }
consdout() { }
I 10
#if NDZ > 0
E 10
dzdma() { dzxint((struct tty *)0); }
I 10
#endif
E 10
E 8

D 8
	dzxint((struct tty *)0);
}
E 8
I 8
D 46
int	catcher[256];
E 46
I 46
quad	catcher[128];
E 46
int	cold = 1;
E 8

D 8
/*ARGSUSED*/
addupc(pc, prof, n)
	caddr_t pc;
	struct uprof *prof;
{
E 8
I 8
Xustray() { }
E 8

D 8
}
E 8
I 8
struct	pte Sysmap[6*NPTEPG];
I 47
#ifdef KADB
E 47
char	Sysbase[6*NPTEPG*NBPG];
I 47
#endif
E 47
int	umbabeg;
struct	pte Nexmap[16][16];
D 10
char	nexus[16][16*NBPG];
E 10
I 10
D 12
struct	nexus nexus[NNEXUS];
E 12
I 12
struct	nexus nexus[MAXNNEXUS];
I 46
#if VAX8600
E 46
I 41
struct	pte Ioamap[MAXNIOA][IOAMAPSIZ/NBPG];
I 46
#endif
E 46
E 41
E 12
E 10
D 23
struct	pte UMEMmap[4][16];
char	umem[4][16*NBPG];
E 23
I 23
D 35
struct	pte UMEMmap[MAXNUBA][512];
char	umem[MAXNUBA][512*NBPG];
E 35
I 35
struct	pte UMEMmap[NUBA][512];
char	umem[NUBA][512*NBPG];
E 35
E 23
int	umbaend;
struct	pte Usrptmap[USRPTSIZE];
struct	pte usrpt[USRPTSIZE*NPTEPG];
struct	pte Forkmap[UPAGES];
struct	user forkutl;
struct	pte Xswapmap[UPAGES];
struct	user xswaputl;
struct	pte Xswap2map[UPAGES];
struct	user xswap2utl;
struct	pte Swapmap[UPAGES];
struct	user swaputl;
struct	pte Pushmap[UPAGES];
struct	user pushutl;
struct	pte Vfmap[UPAGES];
struct	user vfutl;
struct	pte CMAP1;
D 10
char	CADDR1;
E 10
I 10
char	CADDR1[NBPG];
E 10
struct	pte CMAP2;
D 10
char	CADDR2;
E 10
I 10
char	CADDR2[NBPG];
E 10
struct	pte mmap[1];
char	vmmap[NBPG];
I 16
D 19
struct	pte Mbmap[NMBPAGES];
struct	mbuf mbutl[NMBPAGES*NMBPG];
E 19
I 19
struct	pte Mbmap[NMBCLUSTERS/CLSIZE];
struct	mbuf mbutl[NMBCLUSTERS*CLBYTES/sizeof (struct mbuf)];
E 19
E 16
D 9
struct	pte bufmap[NBUF];
char	buffers[NBUF][BSIZE];
E 9
struct	pte msgbufmap[CLSIZE];
D 10
char	msgbuf[CLSIZE*NBPG];
E 10
I 10
struct	msgbuf msgbuf;
E 10
D 45
struct	pte camap[32];
E 45
I 45
D 46
struct	pte kmempt[100];
E 45
I 42
#ifdef VAX630
struct	pte Clockmap[1];
struct	cldevice cldevice;
E 46
I 46
D 47
struct	pte kmempt[200];
E 47
I 47
struct	pte kmempt[200], ekmempt[1];
E 47
#if VAX8200
struct	pte RX50map[1];
struct	pte Ka820map[1];
#endif
#if VAX630
E 46
struct	pte Ka630map[1];
D 46
struct	ka630cpu ka630cpu;
E 46
#endif
E 42
D 38
int	cabase;
E 38
I 38
D 45
int	cabase, calimit;
E 45
I 45
D 47
int	kmembase, kmemlimit;
E 47
I 47
char	kmembase[100*NBPG];
E 47
E 45
E 38
I 10
D 46
#ifdef unneeded
E 10
char	caspace[32*NBPG];
E 46
I 46
#if VAX8200 || VAX630
struct	pte Clockmap[1];
E 46
I 10
#endif
E 10
D 45
int	calimit;
E 45
E 8

/*ARGSUSED*/
D 5
fubyte(base)
	caddr_t base;
E 5
I 5
D 8
copyin(udaddr, kaddr, n)
	caddr_t udaddr, kaddr;
	unsigned n;
E 5
{
E 8
I 8
badaddr(addr, len) caddr_t addr; int len; { return (0); }
E 8
D 23

D 8
	return (0);
}
E 8
I 8
/*ARGSUSED*/
D 10
addupc(pc, prof, n) caddr_t pc; struct uprof *prof; { }
E 10
I 10
addupc(pc, prof, n) int pc; struct uprof *prof; { }
E 23
E 10
E 8

/*ARGSUSED*/
D 5
fuibyte(base)
	caddr_t base;
E 5
I 5
D 8
copyout(kaddr, udaddr, n)
	caddr_t kaddr, udaddr;
	unsigned n;
E 5
{
E 8
I 8
D 38
copyin(udaddr, kaddr, n) caddr_t udaddr, kaddr; unsigned n; { return (0); }
E 38
I 38
ovbcopy(from, to, len) caddr_t from, to; unsigned len; { }
copyinstr(udaddr, kaddr, maxlength, lencopied)
    caddr_t udaddr, kaddr; u_int maxlength, *lencopied;
{ *kaddr = *udaddr; *lencopied = maxlength; return (0); }
copyoutstr(kaddr, udaddr, maxlength, lencopied)
    caddr_t kaddr, udaddr; u_int maxlength, *lencopied;
D 39
{ *kaddr = *udaddr; *lencopied = maxlength; return (0); }
E 39
I 39
{ *udaddr = *kaddr; *lencopied = maxlength; return (0); }
E 39
copystr(kfaddr, kdaddr, maxlength, lencopied)
    caddr_t kfaddr, kdaddr; u_int maxlength, *lencopied;
{ *kdaddr = *kfaddr; *lencopied = maxlength; return (0); }
E 38
E 8

D 8
	return (0);
}
E 8
I 8
/*ARGSUSED*/
D 38
copyout(kaddr, udaddr, n) caddr_t kaddr, udaddr; unsigned n; { return (0); }
E 8

E 38
I 38
copyin(udaddr, kaddr, n) caddr_t udaddr, kaddr; u_int n; { return (0); }
E 38
I 5
D 7
int	whichqs;
struct {
	struct proc *q_forw;
	struct proc *q_rev;
} qs[32];

E 7
E 5
/*ARGSUSED*/
D 5
subyte(base, i)
	caddr_t base;
E 5
I 5
D 8
setjmp(lp)
D 6
	label_t *lp;
E 6
I 6
	label_t lp;
E 6
E 5
{
E 8
I 8
D 24
setjmp(lp) label_t lp; { return (0); }
E 24
I 24
D 38
setjmp(lp) label_t *lp; { return (0); }
E 38
I 38
copyout(kaddr, udaddr, n) caddr_t kaddr, udaddr; u_int n; { return (0); }
E 38
E 24
E 8

D 5
	return (0);
E 5
I 5
D 7
	/*NOTREACHED*/
E 7
I 7
D 8
	return (0);
E 7
E 5
}

E 8
/*ARGSUSED*/
D 5
suibyte(base, i)
	caddr_t base;
E 5
I 5
D 8
longjmp(lp)
D 6
	label_t *lp;
E 6
I 6
	label_t lp;
E 6
E 5
{
E 8
I 8
D 24
longjmp(lp) label_t lp; { /*NOTREACHED*/ }
E 24
I 24
longjmp(lp) label_t *lp; { /*NOTREACHED*/ }
E 24
E 8

D 5
	return (0);
E 5
I 5
D 8
	/*NOTREACHED*/
E 5
}

E 8
/*ARGSUSED*/
I 38
savectx(lp) label_t *lp; { return (0); }

/*ARGSUSED*/
E 38
D 5
fuword(base)
E 5
I 5
D 8
setrq(p)
	struct proc *p;
{
E 8
I 8
setrq(p) struct proc *p; { }
E 8

D 8
}

E 8
/*ARGSUSED*/
D 8
remrq(p)
	struct proc *p;
{
E 8
I 8
remrq(p) struct proc *p; { }
E 8

D 8
}
E 8
I 8
D 10
swtch() { }
E 10
I 10
D 16
swtch() { if (whichqs) whichqs = 0; }
E 16
I 16
D 21
swtch() { if (whichqs) whichqs = 0; masterpaddr = 0; }
E 21
I 21
swtch() { if (whichqs) whichqs = 0; if (masterpaddr) masterpaddr = 0; }
E 21
E 16
E 10
E 8

D 8
swtch()
{

D 7
	whichqs = 0;
E 7
}

E 8
/*ARGSUSED*/
D 8
resume(pcbpf)
	unsigned pcbpf;
{
E 8
I 8
resume(pcbpf) unsigned pcbpf; { }
E 8

D 8
}

E 8
/*ARGSUSED*/
D 8
fubyte(base)
E 5
	caddr_t base;
{
E 8
I 8
fubyte(base) caddr_t base; { return (0); }
I 41
#ifdef notdef
E 41
E 8
D 38

E 38
D 8
	return (0);
}

E 8
/*ARGSUSED*/
I 38
fuibyte(base) caddr_t base; { return (0); }
I 41
#endif
E 41
/*ARGSUSED*/
E 38
D 5
fuiword(base)
E 5
I 5
D 6
fuibyte(base)
E 5
	caddr_t base;
{

	return (0);
}

/*ARGSUSED*/
E 6
D 5
suword(base, i)
E 5
I 5
D 8
subyte(base, i)
E 5
	caddr_t base;
{
E 8
I 8
subyte(base, i) caddr_t base; { return (0); }
E 8
D 38

E 38
D 8
	return (0);
}

E 8
/*ARGSUSED*/
D 5
suiword(base, i)
E 5
I 5
D 8
suibyte(base, i)
E 5
	caddr_t base;
{
E 8
I 8
suibyte(base, i) caddr_t base; { return (0); }
E 8
D 38

E 38
D 8
	return (0);
}

E 8
/*ARGSUSED*/
D 5
copyin(udaddr, kaddr, n)
	caddr_t udaddr, kaddr;
	unsigned n;
E 5
I 5
D 8
fuword(base)
	caddr_t base;
E 5
{
E 8
I 8
fuword(base) caddr_t base; { return (0); }
E 8
D 38

E 38
D 8
	return (0);
}

E 8
/*ARGSUSED*/
D 5
copyout(kaddr, udaddr, n)
	caddr_t kaddr, udaddr;
	unsigned n;
E 5
I 5
D 8
fuiword(base)
	caddr_t base;
E 5
{
E 8
I 8
fuiword(base) caddr_t base; { return (0); }
E 8
D 38

E 38
D 8
	return (0);
}

E 8
D 5
int	whichqs;
struct {
	struct proc *q_forw;
	struct proc *q_rev;
} qs[32];

swtch()
E 5
I 5
/*ARGSUSED*/
D 8
suword(base, i)
	caddr_t base;
E 5
{
E 8
I 8
suword(base, i) caddr_t base; { return (0); }
E 8
D 38

E 38
D 5
	whichqs = 0;
E 5
I 5
D 8
	return (0);
E 5
}

E 8
/*ARGSUSED*/
D 5
resume(pcbpf)
	unsigned pcbpf;
E 5
I 5
D 8
suiword(base, i)
	caddr_t base;
E 5
{
E 8
I 8
suiword(base, i) caddr_t base; { return (0); }
E 8

D 5
	/*NOTREACHED*/
E 5
I 5
D 8
	return (0);
E 5
}

E 8
/*ARGSUSED*/
D 8
copyseg(udaddr, pf)
	caddr_t udaddr;
	unsigned pf;
{
E 8
I 8
D 10
copyseg(udaddr, pf) caddr_t udaddr; unsigned pf; { }
E 10
I 10
D 38
copyseg(udaddr, pf) caddr_t udaddr; unsigned pf; {
    CMAP1 = CMAP1; CADDR1[0] = CADDR1[0];
}
E 38
I 38
copyseg(udaddr, pf)
    caddr_t udaddr; unsigned pf;
{ CMAP1 = CMAP1; CADDR1[0] = CADDR1[0]; }
E 38
E 10
E 8

D 8
}

E 8
/*ARGSUSED*/
D 8
clearseg(pf)
	unsigned pf;
{
E 8
I 8
D 10
clearseg(pf) unsigned pf; { }
E 10
I 10
clearseg(pf) unsigned pf; { CMAP2 = CMAP2; CADDR2[0] = CADDR2[0]; }
E 10
E 8

D 8
}

E 8
/*ARGSUSED*/
D 8
useracc(udaddr, bcnt, rw)
	caddr_t udaddr;
	unsigned bcnt;
{
E 8
I 8
useracc(udaddr, bcnt, rw) caddr_t udaddr; unsigned bcnt; { return (0); }
E 8

D 8
	return (0);
}

E 8
/*ARGSUSED*/
D 8
kernacc(addr, bcnt, rw)
	caddr_t addr;
	unsigned bcnt;
{
E 8
I 8
kernacc(addr, bcnt, rw) caddr_t addr; unsigned bcnt; { return (0); }
E 8

I 27
D 38
/*
 * Routines handled by asm.sed script.
 */

E 27
D 8
	return (0);
}

E 8
D 6
/*ARGSUSED*/
udiv(i, j)
	int i, j;
{

	return (0);
}

#ifdef	UNNEEDED
/*ARGSUSED*/
urem(i, j)
	unsigned i, j;
{

	return (0);
}
#endif

E 6
/*VARARGS1*/
E 38
/*ARGSUSED*/
D 8
mtpr(reg, value)
	int reg, value;
{
E 8
I 8
D 38
mtpr(reg, value) int reg, value; { }
E 38
I 38
addupc(pc, prof, counts) int pc; struct uprof *prof; int counts; { }
E 38
E 8

D 8
}

E 8
D 38
/*ARGSUSED*/
D 8
mfpr(reg)
	int reg;
{
E 8
I 8
mfpr(reg) int reg; { return (0); }
E 8

D 8
	return (0);
}
E 8

E 38
I 38
/*
 * Routines expanded by inline.
 */
E 38
D 8
struct	user u;
struct	user swaputl;
struct	user forkutl;
struct	user xswaputl;
struct	user xswap2utl;
struct	user pushutl;
struct	user vfutl;
struct	user pushutl;
E 8
I 8
D 16
spl0() { return (0); }
E 16
I 16
spl0() { }
I 43
splsoftclock() { return (0); }
splnet() { return (0); }
E 43
E 16
D 10
spl1() { return (0); }
E 10
spl4() { return (0); }
spl5() { return (0); }
D 43
spl6() { return (0); }
E 43
I 43
splbio() { return (0); }
spltty() { return (0); }
#ifdef notdef
spl6() { return (0); }		/* not currently used */
#endif
splclock() { return (0); }
E 43
spl7() { return (0); }
I 43
splhigh() { return (0); }
E 43
E 8

D 8
struct	pte usrpt[USRPTSIZE*NPTEPG];

D 2
struct	pte Sysmap[4*NPTEPG];
E 2
I 2
struct	pte Sysmap[6*NPTEPG];
E 2
struct	pte Swapmap[UPAGES];
struct	pte Forkmap[UPAGES];
struct	pte Xswapmap[UPAGES];
struct	pte Xswap2map[UPAGES];
struct	pte Pushmap[UPAGES];
struct	pte Vfmap[UPAGES];
I 6
struct	pte mcrmap[1];
struct	pte bufmap[NBUF];
I 7
struct	pte MBA0map[16], MBA1map[16];
E 7
E 6

struct	pte mmap[1];
struct	pte mcrmap[1];
char	vmmap[NBPG];
int	mcr[3];

struct	pte Usrptmap[USRPTSIZE];

char	buffers[NBUF][BSIZE];
I 5

spl0()
{

	return (0);
}

spl1()
{

	return (0);
}

spl4()
{

	return (0);
}

spl5()
{

	return (0);
}

spl6()
{

	return (0);
}

spl7()
{

	return (0);
}

E 8
I 6
/*ARGSUSED*/
E 6
D 8
splx(s)
	int s;
{
E 8
I 8
splx(s) int s; { }
E 8

D 6
	return (s);
E 6
D 8
}

E 8
/*ARGSUSED*/
D 8
bcopy(to, from, count)
	caddr_t to, from;
D 6
	int count;
E 6
I 6
	unsigned count;
E 6
{

I 7
	mcrmap[0] = 0;
E 7
}
E 8
I 8
D 10
bcopy(to, from, count) caddr_t to, from; unsigned count; { (* int *)mcrmap = 0; }
E 10
I 10
D 12
bcopy(to, from, count) caddr_t to, from; unsigned count;
    { *(int *)mcrmap = 0; }
E 12
I 12
D 15
bcopy(to, from, count) caddr_t to, from; unsigned count; { ; }
E 15
I 15
D 38
bcopy(from, to, count) caddr_t from, to; unsigned count; { ; }
E 38
I 38
bcopy(from, to, len) caddr_t from, to; unsigned len; { }
/*ARGSUSED*/
bzero(base, count) caddr_t base; unsigned count; { }
/*ARGSUSED*/
blkclr(base, count) caddr_t base; unsigned count; { }
E 38
E 15
E 12

/*ARGSUSED*/
I 25
D 38
bzero(base, count) caddr_t base; unsigned count; { ; }
E 38
I 38
/*VARARGS1*/
mtpr(reg, v) int reg; { }
/*ARGSUSED*/
mfpr(reg) int reg; { return (0); }
E 38

/*ARGSUSED*/
D 38
bcmp(s1, s2, count) caddr_t s1, s2; unsigned count; { return (0); }
E 38
I 38
setjmp(lp) label_t *lp; { return (0); }
E 38

I 46
#ifndef VAX630
E 46
/*ARGSUSED*/
I 27
scanc(size, cp, table, mask)
D 38
unsigned size; caddr_t cp, table; int mask; { return (0); }
E 38
I 38
    unsigned size; char *cp, table[]; int mask;
{ return (0); }
I 46
#endif
E 46
E 38

/*ARGSUSED*/
E 27
E 25
D 38
ffs(i) { return (0); }
E 38
I 38
D 41
skpc(mask, size, cp) int mask; char *cp; unsigned size; { return (0); }
E 41
I 41
skpc(mask, size, cp) int mask; int size; char *cp; { return (0); }
E 41
E 38
I 24

D 38
ntohs(s) u_short s; { return ((int)s); }
E 38
I 38
#ifdef notdef
/*ARGSUSED*/
locc(mask, size, cp) int mask; char *cp; unsigned size; { return (0); }
#endif
E 38

D 38
htons(s) u_short s; { return ((int)s); }
E 38
I 38
/*ARGSUSED*/
_insque(p, q) caddr_t p, q; { }
/*ARGSUSED*/
_remque(p) caddr_t p; { }
E 38
I 27

D 38
/*
 * Variables declared for savecore, or
 * implicitly, such as by config or the loader.
 */
char	version[] = "4.2 BSD UNIX ....";
char	etext;
E 38
I 38
/*ARGSUSED*/
ffs(v) long v; { return (0); }

I 41
#ifdef notdef
E 41
imin(a, b) int a, b; { return (a < b ? a : b); }
imax(a, b) int a, b; { return (a > b ? a : b); }
unsigned min(a, b) u_int a, b; { return (a < b ? a : b); }
unsigned max(a, b) u_int a, b; { return (a > b ? a : b); }
I 41
#endif
E 41
D 42
ntohs(s) u_short s; { return ((int)s); }
htons(s) u_short s; { return ((int)s); }
ntohl(l) u_long l; { return ((int)l); }
htonl(l) u_long l; { return ((int)l); }
E 42
I 42
u_short ntohs(s) u_short s; { return ((u_short)s); }
u_short htons(s) u_short s; { return ((u_short)s); }
u_long ntohl(l) u_long l; { return ((u_long)l); }
u_long htonl(l) u_long l; { return ((u_long)l); }
E 42
E 38
E 27
E 24
E 10
E 8
E 5
E 1
