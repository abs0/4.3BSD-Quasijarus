h29774
s 00002/00002/00293
d D 5.2 86/11/12 09:54:32 mckusick 24 23
c add CCI (tahoe) support
e
s 00007/00003/00288
d D 5.1 85/06/05 14:21:19 dist 23 22
c Add copyright
e
s 00010/00010/00281
d D 2.2 85/03/20 15:02:00 ralph 22 21
c changes from donn@utah-cs for common header file for pcc
e
s 00000/00000/00291
d D 2.1 84/02/08 20:41:27 aoki 21 20
c synchronize to version 2
e
s 00000/00000/00291
d D 1.19 83/09/19 06:58:50 thien 20 19
c Restoring to unlinted version
e
s 00024/00019/00267
d D 1.18 83/08/19 04:58:07 thien 19 18
c The changes were made to allow successful linting
e
s 00023/00014/00263
d D 1.17 83/02/01 20:16:16 peter 18 17
c port to the mc68000.  tied to labels generated by ']' lines.
e
s 00011/00001/00266
d D 1.16 82/11/12 19:02:03 mckusick 17 16
c local jumps to globally declared labels must still use jmp instead of jbr
e
s 00023/00016/00244
d D 1.15 82/11/11 19:40:16 mckusick 16 15
c optimize display save/restore and setjmp() to be done only when needed.
e
s 00032/00010/00228
d D 1.14 82/11/10 14:56:18 mckusick 15 14
c get rid of GOTO and replace it with setjmp/longjmp
e
s 00014/00004/00224
d D 1.13 82/08/29 14:04:14 peter 14 13
c once-only error messages for multiple/out-of-order declarations.
e
s 00003/00003/00225
d D 1.12 82/08/26 18:48:30 mckusick 13 12
c convert namelist structure to use unions
e
s 00006/00001/00222
d D 1.11 82/07/16 15:14:49 peter 12 11
c use jmp instead of jbr to external symbols.  `as' botch.
e
s 00031/00003/00192
d D 1.10 81/11/13 17:37:50 peter 11 10
c make labels look different from function names.
e
s 00002/00002/00193
d D 1.9 81/06/01 15:36:33 peter 10 9
c add storage classes to namelist, and use them.
e
s 00017/00056/00178
d D 1.8 81/03/25 18:10:49 peter 9 7
c add sextname() to make up long external names for things.
e
s 00012/00038/00196
d R 1.8 81/03/24 17:53:06 peter 8 7
c add sextname() to make up long external names for things.
e
s 00004/00004/00230
d D 1.7 81/03/08 19:25:57 mckusic 7 6
c merge in onyx changes
e
s 00002/00001/00232
d D 1.6 81/01/10 17:00:22 mckusic 6 5
c convert to "fp", "ap" type display; fix SUCC and PRED
e
s 00054/00023/00179
d D 1.5 80/10/14 22:48:36 peter 5 4
c labels with fully qualified names
e
s 00001/00001/00201
d D 1.4 80/09/04 23:09:43 peter 4 3
c N_PC stabs with subtypes
e
s 00013/00015/00189
d D 1.3 80/09/02 22:06:01 peter 3 2
c interleaved declaration parts
e
s 00001/00001/00203
d D 1.2 80/08/31 17:31:15 peter 2 1
c stabs for separate compilation type checking
e
s 00204/00000/00000
d D 1.1 80/08/27 19:55:14 peter 1 0
c date and time created 80/08/27 19:55:14 by peter
e
u
U
t
T
I 1
D 23
/* Copyright (c) 1979 Regents of the University of California */
E 23
I 23
/*
 * Copyright (c) 1980 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */
E 23

I 19
#ifndef lint
E 19
D 7
static	char sccsid[] = "%Z%%M% %I% %G%";
E 7
I 7
D 23
static char sccsid[] = "%Z%%M% %I% %G%";
I 19
#endif
E 23
I 23
static char sccsid[] = "%W% (Berkeley) %G%";
#endif not lint
E 23
E 19
E 7

#include "whoami.h"
#include "0.h"
#include "tree.h"
#include "opcode.h"
#include "objfmt.h"
#ifdef PC
#   include	"pc.h"
D 22
#   include	"pcops.h"
E 22
I 22
#   include	<pcc.h>
E 22
#endif PC
I 19
#include "tree_ty.h"
E 19

/*
 * Label enters the definitions
 * of the label declaration part
 * into the namelist.
 */
label(r, l)
D 19
	int *r, l;
E 19
I 19
	struct tnode *r;
	int l;
E 19
{
I 14
    static bool	label_order = FALSE;
    static bool	label_seen = FALSE;
E 14
I 9
#ifdef PC
	char	extname[ BUFSIZ ];
#endif PC
E 9
#ifndef PI0
D 19
	register *ll;
E 19
I 19
	register struct tnode *ll;
E 19
	register struct nl *p, *lp;

	lp = NIL;
#else
	send(REVLAB, r);
#endif
	if ( ! progseen ) {
	    level1();
	}
	line = l;
#ifndef PI1
D 3
#ifdef PC
    if (opt('s')) {
	if (parts & (CPRT|TPRT|VPRT)){
E 3
I 3
	if (parts[ cbn ] & (CPRT|TPRT|VPRT|RPRT)){
	    if ( opt( 's' ) ) {
E 3
		standard();
I 14
		error("Label declarations should precede const, type, var and routine declarations");
E 14
D 3
		error("Label declarations must precede const, type and var declarations");
E 3
I 3
	    } else {
D 14
		warning();
E 14
I 14
		if ( !label_order ) {
		    label_order = TRUE;
		    warning();
		    error("Label declarations should precede const, type, var and routine declarations");
		}
E 14
	    }
D 14
	    error("Label declarations should precede const, type, var and routine declarations");
E 14
E 3
	}
D 3
	if (parts & LPRT) {
E 3
I 3
	if (parts[ cbn ] & LPRT) {
	    if ( opt( 's' ) ) {
E 3
		standard();
I 14
		error("All labels should be declared in one label part");
E 14
D 3
		error("All labels must be declared in one label part");
E 3
I 3
	    } else {
D 14
		warning();
E 14
I 14
		if ( !label_seen ) {
		    label_seen = TRUE;
		    warning();
		    error("All labels should be declared in one label part");
		}
E 14
	    }
D 14
	    error("All labels should be declared in one label part");
E 14
E 3
	}
D 3
    }
#endif PC
#ifdef OBJ
	if (parts & (CPRT|TPRT|VPRT))
		error("Label declarations must precede const, type and var declarations");
	if (parts & LPRT)
		error("All labels must be declared in one label part");
#endif OBJ
	parts |= LPRT;
E 3
I 3
	parts[ cbn ] |= LPRT;
E 3
#endif
#ifndef PI0
D 19
	for (ll = r; ll != NIL; ll = ll[2]) {
		l = getlab();
		p = enter(defnl(ll[1], LABEL, 0, l));
E 19
I 19
	for (ll = r; ll != TR_NIL; ll = ll->list_node.next) {
		l = (int) getlab();
		p = enter(defnl((char *) ll->list_node.list, LABEL, NLNIL,
				(int) l));
E 19
		/*
		 * Get the label for the eventual target
		 */
D 19
		p->value[1] = getlab();
E 19
I 19
		p->value[1] = (int) getlab();
E 19
		p->chain = lp;
		p->nl_flags |= (NFORWD|NMOD);
		p->value[NL_GOLEV] = NOTYET;
D 13
		p->entloc = l;
E 13
I 13
		p->value[NL_ENTLOC] = l;
E 13
		lp = p;
#		ifdef OBJ
		    /*
		     * This operator is between
		     * the bodies of two procedures
		     * and provides a target for
		     * gotos for this label via TRA.
		     */
D 19
		    putlab(l);
D 6
		    put2(O_GOTO | cbn<<8+INDX, p->value[1]);
E 6
I 6
D 7
		    /* put(2, O_GOTO | cbn<<8+INDX, p->value[1]); */
		    put(2, O_GOTO | cbn<<8, p->value[1]);
E 7
I 7
D 16
		    /* put(2, O_GOTO | cbn<<8+INDX, (long)p->value[1]); */
E 16
		    put(2, O_GOTO | cbn<<8, (long)p->value[1]);
E 19
I 19
		    (void) putlab((char *) l);
		    (void) put(2, O_GOTO | cbn<<8, (long)p->value[1]);
E 19
E 7
E 6
#		endif OBJ
#		ifdef PC
		    /*
		     *	labels have to be .globl otherwise /lib/c2 may
		     *	throw them away if they aren't used in the function
		     *	which defines them.
		     */
D 5
		    if (cbn == 1) {
				/*
				 *	stab the label for separate compilation.
				 *	make label number = label name.
				 */
I 2
D 4
			    stabglab( p -> symbol , line );
E 4
I 4
			    stabglabel( p -> symbol , line );
E 4
E 2
			    p -> value[1] = atol( p -> symbol );
D 2
			    stabglab( p -> value[1] );
E 2
			    putprintf( "	.globl	" , 1 );
			    putprintf( PREFIXFORMAT , 0 , PLABELPREFIX
					, p -> value[1] );
		    } else {
			    putprintf( "	.globl	" , 1 );
			    putprintf( PREFIXFORMAT , 0 , GLABELPREFIX
					, p -> value[1] );
E 5
I 5
D 9
		    {
			char	extname[ BUFSIZ ];
			char	*starthere;
			int	i;

			starthere = &extname[0];
			for ( i = 1 ; i < cbn ; i++ ) {
			    sprintf( starthere , EXTFORMAT , enclosing[ i ] );
			    starthere += strlen( enclosing[ i ] ) + 1;
			}
			sprintf( starthere , EXTFORMAT , p -> symbol );
			starthere += strlen( p -> symbol ) + 1;
			if ( starthere >= &extname[ BUFSIZ ] ) {
			    panic( "lab decl namelength" );
			}
			putprintf( "	.globl	" , 1 );
			putprintf( NAMEFORMAT , 0 , extname );
			if ( cbn == 1 ) {
			    stabglabel( extname , line );
			}
E 9
I 9
D 11
		    sextname( extname , p -> symbol , cbn );
E 11
I 11
		    extlabname( extname , p -> symbol , cbn );
E 11
D 18
		    putprintf( "	.globl	%s" , 0 , extname );
E 18
I 18
D 19
		    putprintf("	.globl	%s", 0, extname);
E 19
I 19
		    putprintf("	.globl	%s", 0, (int) extname);
E 19
E 18
		    if ( cbn == 1 ) {
			stabglabel( extname , line );
E 9
E 5
		    }
#		endif PC
	}
	gotos[cbn] = lp;
#	ifdef PTREE
	    {
		pPointer	Labels = LabelDCopy( r );

		pDEF( PorFHeader[ nesting ] ).PorFLabels = Labels;
	    }
#	endif PTREE
#endif
}

#ifndef PI0
/*
 * Gotoop is called when
 * we get a statement "goto label"
 * and generates the needed tra.
 */
gotoop(s)
	char *s;
{
	register struct nl *p;
I 9
#ifdef PC
	char	extname[ BUFSIZ ];
#endif PC
E 9

	gocnt++;
	p = lookup(s);
	if (p == NIL)
D 19
		return (NIL);
E 19
I 19
		return;
E 19
#	ifdef OBJ
D 7
	    put2(O_TRA4, p->entloc);
E 7
I 7
D 13
	    put(2, O_TRA4, (long)p->entloc);
E 13
I 13
D 19
	    put(2, O_TRA4, (long)p->value[NL_ENTLOC]);
E 19
I 19
	    (void) put(2, O_TRA4, (long)p->value[NL_ENTLOC]);
E 19
E 13
E 7
#	endif OBJ
#	ifdef PC
D 16
	    if ( cbn != bn ) {
E 16
I 16
	    if ( cbn == bn ) {
E 16
		    /*
I 16
		     *	local goto.
		     */
		extlabname( extname , p -> symbol , bn );
D 17
		putprintf( "	jbr	%s" , 0 , extname );
E 17
I 17
		    /*
D 18
		     *	this is a jmp because it's a jump to a label that
		     *	has been declared global. Although this branch is
		     *	within this module the assembler will complain that
		     *	the destination is a global symbol. The complaint
		     *	arises because the assembler doesn't change jbr's
		     *	into jmp's and consequently may cause a branch 
		     *	displacement overflow when the module is subsequently
		     *	linked into the rest of the program.
E 18
I 18
		     * this is a funny jump because it's to a label that
		     * has been declared global.
		     * Although this branch is within this module
		     * the assembler will complain that the destination
		     * is a global symbol.
		     * The complaint arises because the assembler
		     * doesn't change relative jumps into absolute jumps.
		     * and this  may cause a branch displacement overflow
		     * when the module is subsequently linked with
		     * the rest of the program.
E 18
		     */
D 18
		putprintf( "	jmp	%s" , 0 , extname );
E 18
I 18
D 24
#		ifdef vax
E 24
I 24
#		if defined(vax) || defined(tahoe)
E 24
D 19
		    putprintf("	jmp	%s", 0, extname);
E 19
I 19
		    putprintf("	jmp	%s", 0, (int) extname);
E 19
D 24
#		endif vax
E 24
I 24
#		endif vax || tahoe
E 24
#		ifdef mc68000
D 19
		    putprintf("	jra	%s", 0, extname);
E 19
I 19
		    putprintf("	jra	%s", 0, (int) extname);
E 19
#		endif mc68000
E 18
E 17
	    } else {
		    /*
		     *	Non-local goto.
		     *
E 16
D 15
		     *	call goto to unwind the stack to the destination level
E 15
I 15
		     *  Close all active files between top of stack and
		     *  frame at the destination level.	Then call longjmp
		     *	to unwind the stack to the destination level.
I 16
		     *
D 18
		     *	For nested routines the end is calculated as:
		     *	__disply[ bn ] . ap + sizeof( local frame )
E 18
I 18
		     *	For nested routines the end of the frame
		     *	is calculated as:
		     *	    __disply[bn].fp + sizeof(local frame)
		     *	(adjusted by (sizeof int) to get just past the end).
E 18
		     *	The size of the local frame is dumped out by
		     *	the second pass as an assembler constant.
		     *	The main routine may not be compiled in this
		     *	module, so its size may not be available.
		     * 	However all of its variables will be globally
		     *	declared, so only the known runtime temporaries
		     *	will be in its stack frame.
E 16
E 15
		     */
I 16
		parts[ bn ] |= NONLOCALGOTO;
E 16
D 22
		putleaf( P2ICON , 0 , 0 , ADDTYPE( P2FTN | P2INT , P2PTR )
E 22
I 22
		putleaf( PCC_ICON , 0 , 0 , PCCM_ADDTYPE( PCCTM_FTN | PCCT_INT , PCCTM_PTR )
E 22
D 15
			, "_GOTO" );
D 10
		putLV( DISPLAYNAME , 0 , bn * sizeof( struct dispsave )
			, P2PTR | P2INT );
E 10
I 10
		putLV( DISPLAYNAME , 0 , bn * sizeof( struct dispsave ) ,
E 15
I 15
			, "_PCLOSE" );
D 16
		putRV( DISPLAYNAME , 0 ,
			bn * sizeof( struct dispsave ) + sizeof ( char * ) ,
E 15
			NGLOBAL , P2PTR | P2INT );
E 16
I 15
		if ( bn > 1 ) {
		    p = lookup( enclosing[ bn - 1 ] );
D 18
		    sprintf( extname, "LF%d+%d", p -> value[ NL_ENTLOC ]
			, sizeof( int ) );
E 18
I 18
		    sprintf( extname, "%s%d+%d",
			FRAME_SIZE_LABEL, p -> value[NL_ENTLOC], sizeof(int));
E 18
D 16
		    putleaf( P2ICON , 0 , 0 , P2INT , extname );
E 16
		    p = lookup(s);
I 16
D 22
		    putLV( extname , bn , 0 , NNLOCAL , P2PTR | P2CHAR );
E 22
I 22
		    putLV( extname , bn , 0 , NNLOCAL , PCCTM_PTR | PCCT_CHAR );
E 22
E 16
		} else {
D 16
		    putleaf( P2ICON , DPOFF1 + sizeof( int ) , 0 , P2INT , 0 );
E 16
I 16
D 19
		    putLV( 0 , bn , -( DPOFF1 + sizeof( int ) ) , LOCALVAR ,
E 19
I 19
		    putLV((char *) 0 , bn , -( DPOFF1 + sizeof( int ) ) , LOCALVAR ,
E 19
D 22
			P2PTR | P2CHAR );
E 22
I 22
			PCCTM_PTR | PCCT_CHAR );
E 22
E 16
		}
D 16
		putop( P2MINUS , P2PTR | P2CHAR );
E 16
E 15
E 10
D 22
		putop( P2CALL , P2INT );
E 22
I 22
		putop( PCC_CALL , PCCT_INT );
E 22
		putdot( filename , line );
I 15
D 22
		putleaf( P2ICON , 0 , 0 , ADDTYPE( P2FTN | P2INT , P2PTR )
E 22
I 22
		putleaf( PCC_ICON , 0 , 0 , PCCM_ADDTYPE( PCCTM_FTN | PCCT_INT , PCCTM_PTR )
E 22
			, "_longjmp" );
D 19
		putLV( 0 , bn , GOTOENVOFFSET , NLOCAL , P2PTR|P2STRTY );
E 19
I 19
D 22
		putLV((char *) 0 , bn , GOTOENVOFFSET , NLOCAL , P2PTR|P2STRTY );
E 22
I 22
		putLV((char *) 0 , bn , GOTOENVOFFSET , NLOCAL , PCCTM_PTR|PCCT_STRTY );
E 22
E 19
		extlabname( extname , p -> symbol , bn );
D 22
		putLV( extname , 0 , 0 , NGLOBAL , P2PTR|P2STRTY );
		putop( P2LISTOP , P2INT );
		putop( P2CALL , P2INT );
E 22
I 22
		putLV( extname , 0 , 0 , NGLOBAL , PCCTM_PTR|PCCT_STRTY );
		putop( PCC_CM , PCCT_INT );
		putop( PCC_CALL , PCCT_INT );
E 22
		putdot( filename , line );
D 16
	    } else {
		extlabname( extname , p -> symbol , bn );
		    /*
		     *	this is a jmp because it's a jump to a global
		     *	and the assembler doesn't change jbr's into jmp's
		     *	if the destination is a global symbol.
		     */
		putprintf( "	jmp	%s" , 0 , extname );
E 16
E 15
	    }
D 5
	    if ( bn <= 1 ) {
		printjbr( PLABELPREFIX , p -> value[1] );
	    } else {
		printjbr( GLABELPREFIX , p -> value[1] );
E 5
I 5
D 9
	    {
		char	extname[ BUFSIZ ];
		char	*starthere;
		int	i;

		starthere = &extname[0];
		for ( i = 1 ; i < bn ; i++ ) {
		    sprintf( starthere , EXTFORMAT , enclosing[ i ] );
		    starthere += strlen( enclosing[ i ] ) + 1;
		}
		sprintf( starthere , EXTFORMAT , p -> symbol );
		starthere += strlen( p -> symbol ) + 1;
		if ( starthere >= &extname[ BUFSIZ ] ) {
		    panic( "goto namelength" );
		}
		putprintf( "	jbr	" , 1 );
		putprintf( NAMEFORMAT , 0 , extname );
E 5
	    }
E 9
I 9
D 11
	    sextname( extname , p -> symbol , bn );
E 11
I 11
D 15
	    extlabname( extname , p -> symbol , bn );
E 11
D 12
	    putprintf( "	jbr	%s" , 0 , extname );
E 12
I 12
		/*
		 *	this is a jmp because it's a jump to a global
		 *	and the assembler doesn't change jbr's into jmp's
		 *	if the destination is a global symbol.
		 */
	    putprintf( "	jmp	%s" , 0 , extname );
E 15
E 12
E 9
#	endif PC
	if (bn == cbn)
		if (p->nl_flags & NFORWD) {
			if (p->value[NL_GOLEV] == NOTYET) {
				p->value[NL_GOLEV] = level;
				p->value[NL_GOLINE] = line;
			}
		} else
			if (p->value[NL_GOLEV] == DEAD) {
				recovered();
				error("Goto %s is into a structured statement", p->symbol);
			}
}

/*
 * Labeled is called when a label
 * definition is encountered, and
 * marks that it has been found and
 * patches the associated GOTO generated
 * by gotoop.
 */
labeled(s)
	char *s;
{
	register struct nl *p;
I 9
#ifdef PC
	char	extname[ BUFSIZ ];
#endif PC
E 9

	p = lookup(s);
	if (p == NIL)
D 19
		return (NIL);
E 19
I 19
		return;
E 19
	if (bn != cbn) {
		error("Label %s not defined in correct block", s);
		return;
	}
	if ((p->nl_flags & NFORWD) == 0) {
		error("Label %s redefined", s);
		return;
	}
	p->nl_flags &= ~NFORWD;
#	ifdef OBJ
D 13
	    patch4(p->entloc);
E 13
I 13
D 19
	    patch4(p->value[NL_ENTLOC]);
E 19
I 19
	    patch4((PTR_DCL) p->value[NL_ENTLOC]);
E 19
E 13
#	endif OBJ
#	ifdef PC
D 5
	    if ( bn <= 1 ) {
		putprintf( PREFIXFORMAT , 1 , PLABELPREFIX , p -> value[1] );
	    } else {
		putprintf( PREFIXFORMAT , 1 , GLABELPREFIX , p -> value[1] );
E 5
I 5
D 9
	    {
		char	extname[ BUFSIZ ];
		char	*starthere;
		int	i;

		starthere = &extname[0];
		for ( i = 1 ; i < bn ; i++ ) {
		    sprintf( starthere , EXTFORMAT , enclosing[ i ] );
		    starthere += strlen( enclosing[ i ] ) + 1;
		}
		sprintf( starthere , EXTFORMAT , p -> symbol );
		starthere += strlen( p -> symbol ) + 1;
		if ( starthere >= &extname[ BUFSIZ ] ) {
		    panic( "labeled namelength" );
		}
		putprintf( NAMEFORMAT , 1 , extname );
		putprintf( ":" , 0 );
E 5
	    }
E 9
I 9
D 11
	    sextname( extname , p -> symbol , bn );
E 11
I 11
	    extlabname( extname , p -> symbol , bn );
E 11
D 19
	    putprintf( "%s:" , 0 , extname );
E 19
I 19
	    putprintf( "%s:" , 0 , (int) extname );
E 19
E 9
D 5
	    putprintf( ":" , 0 );
E 5
#	endif PC
	if (p->value[NL_GOLEV] != NOTYET)
		if (p->value[NL_GOLEV] < level) {
			recovered();
D 19
			error("Goto %s from line %d is into a structured statement", s, p->value[NL_GOLINE]);
E 19
I 19
			error("Goto %s from line %d is into a structured statement", s, (char *) p->value[NL_GOLINE]);
E 19
		}
	p->value[NL_GOLEV] = level;
}
#endif
I 11

#ifdef PC
    /*
     *	construct the long name of a label based on it's static nesting.
     *	into a caller-supplied buffer (that should be about BUFSIZ big).
     */
extlabname( buffer , name , level )
    char	buffer[];
    char	*name;
    int		level;
{
    char	*starthere;
    int		i;

    starthere = &buffer[0];
    for ( i = 1 ; i < level ; i++ ) {
	sprintf( starthere , EXTFORMAT , enclosing[ i ] );
	starthere += strlen( enclosing[ i ] ) + 1;
    }
    sprintf( starthere , EXTFORMAT , "" );
    starthere += 1;
    sprintf( starthere , LABELFORMAT , name );
    starthere += strlen( name ) + 1;
    if ( starthere >= &buffer[ BUFSIZ ] ) {
	panic( "extlabname" );
    }
}
#endif PC
E 11
E 1
